import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  Index,
} from 'typeorm';
import {
  TreeNode,
  DocumentMetadata,
} from '../modules/pageindex/interfaces/tree-node.interface';
import { DocumentType } from '../modules/pageindex/dto/index-document.dto';

/**
 * Status of a document indexing operation.
 *
 * @see Issue #1551 - [PI-1538b] Criar DocumentTree entity e migrations
 */
export enum DocumentTreeStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  INDEXED = 'indexed',
  ERROR = 'error',
}

/**
 * DocumentTree entity for persisting hierarchical document structures
 * indexed by PageIndex.
 *
 * PageIndex organizes documents into a tree structure for reasoning-based
 * retrieval. Unlike traditional RAG approaches that use vector embeddings
 * and chunking, PageIndex preserves the natural document hierarchy and
 * uses LLM reasoning to navigate it.
 *
 * Key benefits:
 * - 98.7% accuracy (vs ~70-80% for embedding-based RAG)
 * - No vector database required
 * - Auditable retrieval path
 * - Human-like document navigation
 *
 * @see Issue #1551 - [PI-1538b] Criar DocumentTree entity e migrations
 * @see Issue #1538 - feat(backend): Criar modulo PageIndex
 * @see https://github.com/VectifyAI/PageIndex
 */
@Entity('document_trees')
@Index(['documentType', 'status']) // For filtering by type and status
@Index(['status', 'createdAt']) // For processing queue
export class DocumentTree {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  /**
   * Human-readable name for the document.
   * Ex: "Lei 14.133/2021 - Nova Lei de Licitacoes"
   */
  @Column({ length: 500 })
  documentName: string;

  /**
   * Path to the source document file (optional).
   * Used when document was uploaded to server storage.
   */
  @Column({ type: 'varchar', length: 1000, nullable: true })
  documentPath: string | null;

  /**
   * Source URL where document was fetched from (optional).
   * Used for web-sourced documents like legislation.
   */
  @Column({ type: 'varchar', length: 2000, nullable: true })
  sourceUrl: string | null;

  /**
   * Type of document for specialized processing.
   */
  @Column({
    type: 'enum',
    enum: DocumentType,
    default: DocumentType.OTHER,
  })
  documentType: DocumentType;

  /**
   * Hierarchical tree structure generated by PageIndex.
   * Contains all nodes from root to leaves with their content.
   * Stored as JSONB for efficient querying.
   */
  @Column({ type: 'jsonb', nullable: true })
  treeStructure: TreeNode | null;

  /**
   * Document metadata (page count, word count, etc.).
   */
  @Column({ type: 'jsonb', nullable: true })
  metadata: DocumentMetadata | null;

  /**
   * Current status of the indexing operation.
   */
  @Column({
    type: 'enum',
    enum: DocumentTreeStatus,
    default: DocumentTreeStatus.PENDING,
  })
  status: DocumentTreeStatus;

  /**
   * Error message if indexing failed.
   */
  @Column({ type: 'text', nullable: true })
  error: string | null;

  /**
   * Total number of nodes in the tree (for statistics).
   */
  @Column({ type: 'int', default: 0 })
  nodeCount: number;

  /**
   * Maximum depth of the tree (for statistics).
   */
  @Column({ type: 'int', default: 0 })
  maxDepth: number;

  /**
   * Processing time in milliseconds (for performance monitoring).
   */
  @Column({ type: 'int', nullable: true })
  processingTimeMs: number | null;

  /**
   * When the document was successfully indexed.
   */
  @Column({ type: 'timestamp', nullable: true })
  indexedAt: Date | null;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}
