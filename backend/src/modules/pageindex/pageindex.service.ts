import {
  Injectable,
  Logger,
  NotFoundException,
  Inject,
  forwardRef,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ConfigService } from '@nestjs/config';
import {
  TreeNode,
  TreeSearchResult,
  TreeSearchOptions,
} from './interfaces/tree-node.interface';
import { IndexDocumentDto, DocumentType } from './dto/index-document.dto';
import {
  DocumentTree,
  DocumentTreeStatus,
} from '../../entities/document-tree.entity';
import { TreeSearchService } from './services/tree-search.service';

/**
 * Result of a document indexing operation.
 */
export interface IndexingResult {
  /** Generated tree ID */
  treeId: string;

  /** Name of the document */
  documentName: string;

  /** Type of document */
  documentType: DocumentType;

  /** Current status of the indexing */
  status: DocumentTreeStatus;

  /** Tree structure (null if not yet indexed) */
  tree?: TreeNode | null;

  /** Error message if status is ERROR */
  error?: string | null;

  /** When the document was indexed */
  indexedAt?: Date | null;

  /** Number of nodes in the tree */
  nodeCount: number;

  /** Maximum depth of the tree */
  maxDepth: number;
}

/**
 * PageIndex Service - Core service for hierarchical document indexing.
 *
 * This service provides CRUD operations for DocumentTree entities and
 * the foundation for PageIndex integration with reasoning-based retrieval.
 *
 * Key differences from traditional RAG:
 * - No vector database required
 * - No chunking - uses natural document structure
 * - LLM reasoning for navigation (like a human expert)
 * - 98.7% accuracy vs ~70-80% for traditional RAG
 *
 * Current implementation:
 * - #1550: Module structure ✅
 * - #1551: DocumentTree entity and CRUD operations ✅
 * - #1552: TreeBuilderService (actual tree generation) ✅
 * - #1553: TreeSearchService (LLM reasoning search) ✅
 *
 * Remaining:
 * - #1554: PoC with Lei 14.133/2021
 *
 * @see Issue #1551 - [PI-1538b] Criar DocumentTree entity e migrations
 * @see Issue #1538 - Create PageIndex module for hierarchical document indexing
 * @see https://github.com/VectifyAI/PageIndex
 */
@Injectable()
export class PageIndexService {
  private readonly logger = new Logger(PageIndexService.name);

  constructor(
    @InjectRepository(DocumentTree)
    private readonly documentTreeRepository: Repository<DocumentTree>,
    private readonly configService: ConfigService,
    @Inject(forwardRef(() => TreeSearchService))
    private readonly treeSearchService: TreeSearchService,
  ) {
    this.logger.log(
      'PageIndexService initialized with DocumentTree repository',
    );
  }

  /**
   * Create a pending document tree entry.
   * The actual tree structure will be generated by TreeBuilderService (#1552).
   *
   * @param dto - Document indexing request
   * @returns IndexingResult with tree ID and pending status
   */
  async createDocumentTree(dto: IndexDocumentDto): Promise<IndexingResult> {
    this.logger.log('Creating document tree entry', {
      documentName: dto.documentName,
      documentType: dto.documentType || DocumentType.OTHER,
    });

    const documentTree = this.documentTreeRepository.create({
      documentName: dto.documentName,
      documentPath: dto.documentPath || null,
      sourceUrl: dto.sourceUrl || null,
      documentType: dto.documentType || DocumentType.OTHER,
      status: DocumentTreeStatus.PENDING,
      treeStructure: null,
      metadata: null,
      nodeCount: 0,
      maxDepth: 0,
    });

    const saved = await this.documentTreeRepository.save(documentTree);

    this.logger.log('Document tree entry created', { treeId: saved.id });

    return this.toIndexingResult(saved);
  }

  /**
   * Index a document and generate its hierarchical tree structure.
   * Currently creates a pending entry - actual processing in #1552.
   *
   * @param dto - Document indexing request
   * @returns IndexingResult with tree ID and status
   */
  async indexDocument(dto: IndexDocumentDto): Promise<IndexingResult> {
    this.logger.log('indexDocument called', {
      documentName: dto.documentName,
      documentType: dto.documentType || DocumentType.OTHER,
      hasPath: !!dto.documentPath,
      hasContent: !!dto.content,
      hasSourceUrl: !!dto.sourceUrl,
    });

    // Create the document tree entry with pending status
    const result = await this.createDocumentTree(dto);

    // TODO #1552: Trigger TreeBuilderService to process the document
    // For now, the document remains in PENDING status
    this.logger.log('Document queued for indexing', { treeId: result.treeId });

    return result;
  }

  /**
   * Search a document tree using LLM reasoning.
   *
   * This method delegates to TreeSearchService which implements the PageIndex
   * algorithm: LLM-based reasoning to navigate document structure instead of
   * traditional vector similarity search.
   *
   * @param treeId - ID of the document tree to search
   * @param query - Natural language query
   * @param options - Search options (depth, results, confidence)
   * @returns TreeSearchResult with relevant nodes and reasoning
   *
   * @throws NotFoundException if tree not found
   * @throws Error if tree not indexed yet
   *
   * @see Issue #1553 - [PI-1538d] Implementar TreeSearchService com LLM reasoning
   */
  async searchTree(
    treeId: string,
    query: string,
    options?: TreeSearchOptions,
  ): Promise<TreeSearchResult> {
    this.logger.log('searchTree called', {
      treeId,
      query: query.substring(0, 100),
      options,
    });

    return this.treeSearchService.search(treeId, query, options);
  }

  /**
   * Get a document tree by ID.
   *
   * @param treeId - ID of the document tree
   * @returns The document tree or null if not found
   */
  async getTree(treeId: string): Promise<IndexingResult | null> {
    this.logger.log('getTree called', { treeId });

    const tree = await this.documentTreeRepository.findOne({
      where: { id: treeId },
    });

    if (!tree) {
      return null;
    }

    return this.toIndexingResult(tree);
  }

  /**
   * List all indexed document trees.
   *
   * @param options - Optional filter options
   * @returns Array of indexing results
   */
  async listTrees(options?: {
    status?: DocumentTreeStatus;
    documentType?: DocumentType;
    limit?: number;
    offset?: number;
  }): Promise<IndexingResult[]> {
    this.logger.log('listTrees called', options);

    const queryBuilder = this.documentTreeRepository.createQueryBuilder('tree');

    if (options?.status) {
      queryBuilder.andWhere('tree.status = :status', {
        status: options.status,
      });
    }

    if (options?.documentType) {
      queryBuilder.andWhere('tree.documentType = :documentType', {
        documentType: options.documentType,
      });
    }

    queryBuilder
      .orderBy('tree.createdAt', 'DESC')
      .take(options?.limit || 100)
      .skip(options?.offset || 0);

    const trees = await queryBuilder.getMany();

    return trees.map((tree) => this.toIndexingResult(tree));
  }

  /**
   * Delete a document tree.
   *
   * @param treeId - ID of the document tree to delete
   * @throws NotFoundException if tree not found
   */
  async deleteTree(treeId: string): Promise<void> {
    this.logger.log('deleteTree called', { treeId });

    const result = await this.documentTreeRepository.delete(treeId);

    if (result.affected === 0) {
      throw new NotFoundException(`Document tree ${treeId} not found`);
    }

    this.logger.log('Document tree deleted', { treeId });
  }

  /**
   * Update the status of a document tree.
   * Used by TreeBuilderService during processing.
   *
   * @param treeId - ID of the document tree
   * @param status - New status
   * @param additionalData - Optional data to update
   */
  async updateTreeStatus(
    treeId: string,
    status: DocumentTreeStatus,
    additionalData?: Partial<{
      treeStructure: TreeNode;
      error: string;
      nodeCount: number;
      maxDepth: number;
      processingTimeMs: number;
      indexedAt: Date;
    }>,
  ): Promise<IndexingResult> {
    this.logger.log('updateTreeStatus called', { treeId, status });

    const tree = await this.documentTreeRepository.findOne({
      where: { id: treeId },
    });

    if (!tree) {
      throw new NotFoundException(`Document tree ${treeId} not found`);
    }

    tree.status = status;

    if (additionalData) {
      if (additionalData.treeStructure !== undefined) {
        tree.treeStructure = additionalData.treeStructure;
      }
      if (additionalData.error !== undefined) {
        tree.error = additionalData.error;
      }
      if (additionalData.nodeCount !== undefined) {
        tree.nodeCount = additionalData.nodeCount;
      }
      if (additionalData.maxDepth !== undefined) {
        tree.maxDepth = additionalData.maxDepth;
      }
      if (additionalData.processingTimeMs !== undefined) {
        tree.processingTimeMs = additionalData.processingTimeMs;
      }
      if (additionalData.indexedAt !== undefined) {
        tree.indexedAt = additionalData.indexedAt;
      }
    }

    const saved = await this.documentTreeRepository.save(tree);

    return this.toIndexingResult(saved);
  }

  /**
   * Get PageIndex service statistics.
   *
   * @returns Statistics about indexed documents
   */
  async getStats(): Promise<{
    totalDocuments: number;
    byStatus: Record<DocumentTreeStatus, number>;
    byType: Record<DocumentType, number>;
  }> {
    this.logger.log('getStats called');

    const totalDocuments = await this.documentTreeRepository.count();

    // Count by status
    const statusCounts = await this.documentTreeRepository
      .createQueryBuilder('tree')
      .select('tree.status', 'status')
      .addSelect('COUNT(*)', 'count')
      .groupBy('tree.status')
      .getRawMany();

    const byStatus: Record<DocumentTreeStatus, number> = {
      [DocumentTreeStatus.PENDING]: 0,
      [DocumentTreeStatus.PROCESSING]: 0,
      [DocumentTreeStatus.INDEXED]: 0,
      [DocumentTreeStatus.ERROR]: 0,
    };

    for (const row of statusCounts) {
      byStatus[row.status as DocumentTreeStatus] = parseInt(row.count, 10);
    }

    // Count by type
    const typeCounts = await this.documentTreeRepository
      .createQueryBuilder('tree')
      .select('tree.documentType', 'type')
      .addSelect('COUNT(*)', 'count')
      .groupBy('tree.documentType')
      .getRawMany();

    const byType: Record<DocumentType, number> = {
      [DocumentType.LEGISLATION]: 0,
      [DocumentType.JURISPRUDENCIA]: 0,
      [DocumentType.CONTRACT]: 0,
      [DocumentType.EDITAL]: 0,
      [DocumentType.TERMO_REFERENCIA]: 0,
      [DocumentType.ETP]: 0,
      [DocumentType.OTHER]: 0,
    };

    for (const row of typeCounts) {
      byType[row.type as DocumentType] = parseInt(row.count, 10);
    }

    return {
      totalDocuments,
      byStatus,
      byType,
    };
  }

  /**
   * Convert a DocumentTree entity to an IndexingResult.
   */
  private toIndexingResult(tree: DocumentTree): IndexingResult {
    return {
      treeId: tree.id,
      documentName: tree.documentName,
      documentType: tree.documentType,
      status: tree.status,
      tree: tree.treeStructure,
      error: tree.error,
      indexedAt: tree.indexedAt,
      nodeCount: tree.nodeCount,
      maxDepth: tree.maxDepth,
    };
  }
}
