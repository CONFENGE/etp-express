[{"body":"## Context\nIssue pai: #109 (desmembrada para atomicidade)\n\nPara conformidade de seguran√ßa e detec√ß√£o de ataques, √© cr√≠tico saber:\n- Quem acessou cada secret?\n- Quando foi acessado?\n- De onde (IP, servi√ßo)?\n- Houve tentativas de acesso n√£o autorizado?\n\n**Audit trail** registra todos os acessos a secrets e gera alertas para padr√µes an√¥malos.\n\n## Objective\nImplementar sistema de audit trail que registra todos os acessos a secrets, detecta acessos an√¥malos e envia alertas.\n\n## File Location\n**Arquivos a criar/modificar:**\n- `backend/src/config/secrets.service.ts` (modificar - adicionar logging de acesso)\n- `backend/src/audit/audit.module.ts` (criar - m√≥dulo de auditoria)\n- `backend/src/audit/audit.service.ts` (criar - servi√ßo de auditoria)\n- `backend/src/audit/entities/secret-access-log.entity.ts` (criar - entidade TypeORM)\n- `backend/src/audit/audit.controller.ts` (criar - endpoint para consultar logs)\n- `backend/migrations/XXXXXX-create-secret-access-logs.ts` (criar - migration)\n- `backend/test/audit/secret-access-audit.spec.ts` (criar - testes)\n\n## Technical Approach\n\n### Passo 1: Criar entidade de audit log\nCriar `backend/src/audit/entities/secret-access-log.entity.ts`:\n```typescript\nimport { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn } from 'typeorm';\n\n@Entity('secret_access_logs')\nexport class SecretAccessLog {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column()\n  secretName: string; // Ex: JWT_SECRET, OPENAI_API_KEY\n\n  @Column()\n  accessedBy: string; // Service/user que acessou\n\n  @Column({ nullable: true })\n  ipAddress: string;\n\n  @CreateDateColumn()\n  accessedAt: Date;\n\n  @Column({ default: 'success' })\n  status: 'success' | 'failed' | 'unauthorized';\n\n  @Column({ nullable: true })\n  errorMessage: string;\n}\n```\n\n### Passo 2: Criar AuditService\nCriar `backend/src/audit/audit.service.ts`:\n```typescript\nimport { Injectable, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { SecretAccessLog } from './entities/secret-access-log.entity';\n\n@Injectable()\nexport class AuditService {\n  private readonly logger = new Logger(AuditService.name);\n\n  constructor(\n    @InjectRepository(SecretAccessLog)\n    private logsRepository: Repository<SecretAccessLog>,\n  ) {}\n\n  async logSecretAccess(\n    secretName: string,\n    accessedBy: string,\n    status: 'success' | 'failed',\n    ipAddress?: string,\n    errorMessage?: string,\n  ) {\n    const log = this.logsRepository.create({\n      secretName,\n      accessedBy,\n      status,\n      ipAddress,\n      errorMessage,\n    });\n\n    await this.logsRepository.save(log);\n\n    // Log cr√≠tico se acesso falhou\n    if (status === 'failed') {\n      this.logger.error(\n        `Secret access failed: ${secretName} by ${accessedBy} - ${errorMessage}`,\n      );\n    }\n  }\n\n  async getRecentAccess(secretName: string, limit = 100): Promise<SecretAccessLog[]> {\n    return this.logsRepository.find({\n      where: { secretName },\n      order: { accessedAt: 'DESC' },\n      take: limit,\n    });\n  }\n\n  async detectAnomalies(secretName: string): Promise<boolean> {\n    // Detectar acessos an√¥malos (ex: >100 acessos em 1 minuto)\n    const oneMinuteAgo = new Date(Date.now() - 60 * 1000);\n    \n    const count = await this.logsRepository.count({\n      where: {\n        secretName,\n        accessedAt: MoreThan(oneMinuteAgo),\n      },\n    });\n\n    if (count > 100) {\n      this.logger.warn(`Anomaly detected: ${count} accesses to ${secretName} in last minute`);\n      return true;\n    }\n\n    return false;\n  }\n}\n```\n\n### Passo 3: Integrar AuditService no SecretsService\nModificar `backend/src/config/secrets.service.ts`:\n```typescript\nasync getSecret(name: string): Promise<string> {\n  try {\n    const value = await this.fetchFromProvider(name);\n    \n    // Registrar acesso bem-sucedido\n    await this.auditService.logSecretAccess(\n      name,\n      'SecretsService', // ou contexto de onde foi chamado\n      'success',\n    );\n\n    // Verificar anomalias\n    const isAnomalous = await this.auditService.detectAnomalies(name);\n    if (isAnomalous) {\n      // Enviar alerta (ex: email, Slack, PagerDuty)\n      this.alertService.send(`Anomalous access detected for ${name}`);\n    }\n\n    return value;\n  } catch (error) {\n    // Registrar acesso falho\n    await this.auditService.logSecretAccess(\n      name,\n      'SecretsService',\n      'failed',\n      null,\n      error.message,\n    );\n    \n    throw error;\n  }\n}\n```\n\n### Passo 4: Criar endpoint de consulta\nCriar `backend/src/audit/audit.controller.ts`:\n```typescript\n@Controller('audit')\n@UseGuards(JwtAuthGuard, RolesGuard)\n@Roles('admin') // Apenas admins podem ver logs de auditoria\nexport class AuditController {\n  constructor(private auditService: AuditService) {}\n\n  @Get('secrets/:secretName')\n  async getSecretAccessLogs(@Param('secretName') secretName: string) {\n    return this.auditService.getRecentAccess(secretName);\n  }\n\n  @Get('secrets/:secretName/anomalies')\n  async checkAnomalies(@Param('secretName') secretName: string) {\n    const isAnomalous = await this.auditService.detectAnomalies(secretName);\n    return { secretName, anomalous: isAnomalous };\n  }\n}\n```\n\n### Passo 5: Criar migration\n```bash\nnpm run typeorm:generate -- backend/migrations/CreateSecretAccessLogs\nnpm run typeorm:run\n```\n\n### Passo 6: Criar testes\nCriar `backend/test/audit/secret-access-audit.spec.ts`:\n```typescript\ndescribe('Secret Access Audit', () => {\n  it('should log successful secret access', async () => {\n    await secretsService.getSecret('JWT_SECRET');\n    \n    const logs = await auditService.getRecentAccess('JWT_SECRET');\n    expect(logs).toHaveLength(1);\n    expect(logs[0].status).toBe('success');\n  });\n\n  it('should log failed secret access', async () => {\n    await expect(secretsService.getSecret('INVALID_SECRET')).rejects.toThrow();\n    \n    const logs = await auditService.getRecentAccess('INVALID_SECRET');\n    expect(logs).toHaveLength(1);\n    expect(logs[0].status).toBe('failed');\n  });\n\n  it('should detect anomalies (>100 accesses/min)', async () => {\n    // Simular 150 acessos\n    for (let i = 0; i < 150; i++) {\n      await auditService.logSecretAccess('JWT_SECRET', 'test', 'success');\n    }\n\n    const isAnomalous = await auditService.detectAnomalies('JWT_SECRET');\n    expect(isAnomalous).toBe(true);\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] SecretAccessLog entity criada e migration executada\n- [ ] AuditService implementado com logSecretAccess() e detectAnomalies()\n- [ ] SecretsService integrado com AuditService (loga todos os acessos)\n- [ ] AuditController criado com endpoints GET /audit/secrets/:name\n- [ ] Detec√ß√£o de anomalias funcional (>100 acessos/min gera alerta)\n- [ ] Testes de auditoria criados e passando (3+ cen√°rios)\n- [ ] Valida√ß√£o manual: acessar secret e verificar log no banco de dados\n\n## Dependencies\n- **Blocked by**: #155 (#109c - SecretsService deve existir)\n- **Blocks**: None\n- **Related**: #109 (issue pai)\n\n## Estimated Effort\n‚è±Ô∏è **3 horas** (implementa√ß√£o + migration + testes)\n\n## Risk\nüü° **M√âDIO** - Logging excessivo pode impactar performance\n- **Mitiga√ß√£o**: Usar async logging (n√£o bloquear acesso ao secret)\n- **Mitiga√ß√£o**: Adicionar √≠ndice em `accessedAt` para queries r√°pidas","number":158,"title":"[SEC-109f] Implementar audit trail para acesso a secrets"},{"body":"## Context\nIssue pai: #109 (desmembrada para atomicidade)\n\nRotacionar secrets causa downtime se feito ingenuamente (trocar KEY_OLD por KEY_NEW imediatamente invalida todos os tokens/sess√µes ativas). A estrat√©gia de dual-key permite rota√ß√£o sem downtime.\n\n**Dual-key strategy**: Durante per√≠odo de transi√ß√£o (24-48h), o sistema aceita AMBOS os secrets (antigo e novo). Ap√≥s per√≠odo, remove o antigo.\n\n## Objective\nImplementar suporte a dual-key (chave prim√°ria + chave secund√°ria) para JWT_SECRET e SESSION_SECRET, permitindo rota√ß√£o zero-downtime.\n\n## File Location\n**Arquivos a modificar:**\n- `backend/src/auth/strategies/jwt.strategy.ts` (modificar - aceitar m√∫ltiplos secrets)\n- `backend/src/auth/auth.service.ts` (modificar - gerar tokens com secret prim√°rio)\n- `backend/src/config/secrets.service.ts` (modificar - retornar array de secrets quando dual-key ativo)\n- `backend/src/auth/auth.module.ts` (modificar - configurar dual-key no JwtModule)\n- `backend/test/auth/dual-key.spec.ts` (criar - testes de dual-key)\n\n## Technical Approach\n\n### Passo 1: Modificar SecretsService para suportar dual-key\nAtualizar `backend/src/config/secrets.service.ts`:\n```typescript\nasync getSecret(name: string): Promise<string> {\n  // Buscar secret prim√°rio\n  return this.fetchFromProvider(name);\n}\n\nasync getSecretWithFallback(name: string): Promise<string[]> {\n  const primary = await this.fetchFromProvider(name);\n  \n  try {\n    // Tentar buscar secret secund√°rio (se existir)\n    const secondary = await this.fetchFromProvider(`${name}_OLD`);\n    return [primary, secondary];\n  } catch {\n    // Se n√£o existir, retorna apenas prim√°rio\n    return [primary];\n  }\n}\n```\n\n### Passo 2: Modificar JwtStrategy para aceitar m√∫ltiplos secrets\nAtualizar `backend/src/auth/strategies/jwt.strategy.ts`:\n```typescript\nimport { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { SecretsService } from '../../config/secrets.service';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(private secretsService: SecretsService) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      secretOrKeyProvider: async (request, rawJwtToken, done) => {\n        try {\n          const secrets = await this.secretsService.getSecretWithFallback('JWT_SECRET');\n          \n          // Tentar validar com cada secret (prim√°rio primeiro)\n          for (const secret of secrets) {\n            try {\n              jwt.verify(rawJwtToken, secret);\n              return done(null, secret); // Sucesso\n            } catch (err) {\n              continue; // Tentar pr√≥ximo secret\n            }\n          }\n          \n          // Nenhum secret validou\n          return done(new UnauthorizedException('Invalid token'), null);\n        } catch (error) {\n          return done(error, null);\n        }\n      },\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, email: payload.email };\n  }\n}\n```\n\n### Passo 3: Modificar AuthService para gerar tokens com secret prim√°rio\nAtualizar `backend/src/auth/auth.service.ts`:\n```typescript\nasync generateToken(user: User): Promise<string> {\n  const payload = { sub: user.id, email: user.email };\n  \n  // Sempre gerar com secret prim√°rio (primeiro da lista)\n  const secrets = await this.secretsService.getSecretWithFallback('JWT_SECRET');\n  const primarySecret = secrets[0];\n  \n  return this.jwtService.sign(payload, { secret: primarySecret });\n}\n```\n\n### Passo 4: Criar testes de dual-key\nCriar `backend/test/auth/dual-key.spec.ts`:\n```typescript\ndescribe('Dual-Key Strategy', () => {\n  it('should accept token signed with primary secret', async () => {\n    const token = signToken(payload, PRIMARY_SECRET);\n    const result = await validateToken(token);\n    expect(result).toBeDefined();\n  });\n\n  it('should accept token signed with secondary secret (OLD)', async () => {\n    const token = signToken(payload, SECONDARY_SECRET);\n    const result = await validateToken(token);\n    expect(result).toBeDefined();\n  });\n\n  it('should reject token signed with invalid secret', async () => {\n    const token = signToken(payload, 'INVALID_SECRET');\n    await expect(validateToken(token)).rejects.toThrow(UnauthorizedException);\n  });\n\n  it('should generate new tokens with primary secret only', async () => {\n    const token = await authService.generateToken(user);\n    const decoded = jwt.decode(token);\n    \n    // Validar que foi assinado com secret prim√°rio\n    expect(() => jwt.verify(token, PRIMARY_SECRET)).not.toThrow();\n  });\n});\n```\n\n### Passo 5: Documentar uso\nAdicionar em `docs/SECRET_ROTATION_PROCEDURES.md`:\n```markdown\n## Dual-Key Rotation Process\n\n1. **Day 0**: Generate new secret\n   - Create JWT_SECRET_NEW in secrets manager\n   - Keep JWT_SECRET as is\n\n2. **Day 0 (deployment)**: Enable dual-key\n   - Rename JWT_SECRET to JWT_SECRET_OLD\n   - Rename JWT_SECRET_NEW to JWT_SECRET\n   - Deploy application (now accepts both)\n\n3. **Day 1-2**: Dual-key period\n   - Old tokens (signed with JWT_SECRET_OLD) still work\n   - New tokens (signed with JWT_SECRET) are generated\n\n4. **Day 3**: Remove old secret\n   - Delete JWT_SECRET_OLD from secrets manager\n   - Only JWT_SECRET remains\n   - Deployment complete ‚úÖ\n```\n\n## Acceptance Criteria\n- [ ] SecretsService.getSecretWithFallback() implementado\n- [ ] JwtStrategy modificado para aceitar m√∫ltiplos secrets\n- [ ] AuthService gera tokens apenas com secret prim√°rio\n- [ ] Testes de dual-key criados e passando (4+ cen√°rios)\n- [ ] Teste manual: token antigo v√°lido durante per√≠odo de transi√ß√£o\n- [ ] Documenta√ß√£o de uso adicionada ao runbook\n- [ ] Valida√ß√£o: rota√ß√£o teste em staging com zero 401 errors\n\n## Dependencies\n- **Blocked by**: #155 (#109c - SecretsService deve existir)\n- **Blocks**: None\n- **Related**: #109 (issue pai), #156 (#109d - documenta√ß√£o de rota√ß√£o)\n\n## Estimated Effort\n‚è±Ô∏è **4 horas** (implementa√ß√£o + testes + valida√ß√£o)\n\n## Risk\nüî¥ **ALTO** - Erro na l√≥gica de dual-key pode invalidar todos os tokens ativos\n- **Mitiga√ß√£o**: Testar exaustivamente em staging antes de produ√ß√£o\n- **Rollback**: Manter apenas secret prim√°rio se dual-key falhar","number":157,"title":"[SEC-109e] Implementar dual-key strategy para zero-downtime rotation"},{"body":"## Context\nIssue pai: #109 (desmembrada para atomicidade)\n\nSecrets devem ser rotacionados periodicamente (JWT_SECRET mensalmente, API keys trimestralmente). Sem documenta√ß√£o clara, a rota√ß√£o pode causar downtime ou ser esquecida.\n\n## Objective\nDocumentar procedimento step-by-step de rota√ß√£o para cada secret do sistema, incluindo frequ√™ncia recomendada, pr√©-requisitos, comandos exatos e valida√ß√£o p√≥s-rota√ß√£o.\n\n## File Location\n**Arquivos a criar/modificar:**\n- `docs/SECRET_ROTATION_PROCEDURES.md` (criar - runbook de rota√ß√£o)\n- `scripts/rotate-secret.sh` (criar - script helper de rota√ß√£o)\n- `SECURITY.md` (modificar - adicionar link para procedimentos)\n- `.github/ISSUE_TEMPLATE/rotate-secret.md` (criar - template de issue para rota√ß√£o)\n\n## Technical Approach\n\n### Passo 1: Criar runbook de rota√ß√£o\nCriar `docs/SECRET_ROTATION_PROCEDURES.md` com estrutura:\n\n```markdown\n# Secret Rotation Procedures\n\n## Rotation Schedule\n| Secret | Frequency | Last Rotated | Next Rotation |\n|--------|-----------|--------------|---------------|\n| JWT_SECRET | Monthly | YYYY-MM-DD | YYYY-MM-DD |\n| SESSION_SECRET | Monthly | YYYY-MM-DD | YYYY-MM-DD |\n| OPENAI_API_KEY | Quarterly | YYYY-MM-DD | YYYY-MM-DD |\n| PERPLEXITY_API_KEY | Quarterly | YYYY-MM-DD | YYYY-MM-DD |\n| DATABASE_URL | On-demand | N/A | N/A |\n\n## JWT_SECRET Rotation\n\n### Pre-requisites\n- [ ] Access to secrets manager\n- [ ] Access to Railway dashboard\n- [ ] Backup of current JWT_SECRET value\n\n### Steps\n1. Generate new secret: `openssl rand -base64 32`\n2. Add new secret as JWT_SECRET_NEW in secrets manager\n3. Update application to accept both JWT_SECRET and JWT_SECRET_NEW\n4. Deploy application\n5. Wait 24h (allow time for old tokens to expire or be refreshed)\n6. Remove JWT_SECRET from secrets manager\n7. Rename JWT_SECRET_NEW to JWT_SECRET\n8. Update rotation schedule table\n\n### Validation\n- [ ] Users can login with new tokens\n- [ ] Old tokens still work (during dual-key period)\n- [ ] No 401 Unauthorized errors in logs\n\n### Rollback\nIf issues occur:\n1. Revert to JWT_SECRET (remove JWT_SECRET_NEW)\n2. Redeploy application\n3. Investigate root cause before retrying\n```\n\n(Repetir estrutura similar para cada secret)\n\n### Passo 2: Criar script helper\nCriar `scripts/rotate-secret.sh`:\n```bash\n#!/bin/bash\n# Usage: ./scripts/rotate-secret.sh JWT_SECRET\n\nSECRET_NAME=$1\nNEW_VALUE=$(openssl rand -base64 32)\n\necho \"Rotating secret: $SECRET_NAME\"\necho \"New value: $NEW_VALUE\"\n\n# Adicionar no secrets manager (comando depende da solu√ß√£o)\n# aws secretsmanager create-secret --name ${SECRET_NAME}_NEW --secret-string $NEW_VALUE\n\necho \"‚úÖ Secret rotated. Follow manual steps in SECRET_ROTATION_PROCEDURES.md\"\n```\n\n### Passo 3: Criar template de issue para rota√ß√£o\nCriar `.github/ISSUE_TEMPLATE/rotate-secret.md`:\n```markdown\n---\nname: Secret Rotation\nabout: Rota√ß√£o peri√≥dica de secrets conforme procedimento\ntitle: '[SEC] Rotate SECRET_NAME'\nlabels: security, ops\n---\n\n## Secret to Rotate\n- [ ] JWT_SECRET\n- [ ] SESSION_SECRET\n- [ ] OPENAI_API_KEY\n- [ ] PERPLEXITY_API_KEY\n\n## Checklist\nFollow: `docs/SECRET_ROTATION_PROCEDURES.md`\n\n- [ ] Pre-requisites verified\n- [ ] New secret generated\n- [ ] Dual-key period started\n- [ ] Application deployed with dual-key support\n- [ ] 24h waiting period completed\n- [ ] Old secret removed\n- [ ] Validation tests passed\n- [ ] Rotation schedule table updated\n```\n\n### Passo 4: Adicionar alertas de expira√ß√£o\nAdicionar no runbook:\n```markdown\n## Expiration Alerts\n\nCreate calendar reminders:\n- JWT_SECRET: Day 25 of each month\n- SESSION_SECRET: Day 25 of each month\n- OPENAI_API_KEY: 7 days before quarterly rotation\n- PERPLEXITY_API_KEY: 7 days before quarterly rotation\n\nCreate GitHub Action para lembrar (opcional):\n```yaml\nname: Secret Rotation Reminder\non:\n  schedule:\n    - cron: '0 9 25 * *' # Day 25 of each month at 9am\njobs:\n  remind:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Create issue\n        run: |\n          gh issue create --title \"[SEC] Monthly secret rotation reminder\" \\\n            --body \"Time to rotate JWT_SECRET and SESSION_SECRET\"\n```\n```\n\n## Acceptance Criteria\n- [ ] `docs/SECRET_ROTATION_PROCEDURES.md` criado com procedimentos completos\n- [ ] Procedimento documentado para todos os 5 secrets\n- [ ] Script `scripts/rotate-secret.sh` criado e testado\n- [ ] Template de issue `.github/ISSUE_TEMPLATE/rotate-secret.md` criado\n- [ ] Rotation schedule table preenchida com datas\n- [ ] Valida√ß√£o: seguir procedimento em ambiente de staging e verificar zero-downtime\n- [ ] SECURITY.md atualizado com link para runbook\n\n## Dependencies\n- **Blocked by**: #155 (#109c - migra√ß√£o deve estar completa para testar procedimento)\n- **Blocks**: None\n- **Related**: #109 (issue pai), #153 (#109a), #155 (#109c)\n\n## Estimated Effort\n‚è±Ô∏è **2 horas** (documenta√ß√£o + script + testes)\n\n## Risk\nüü° **M√âDIO** - Procedimento incorreto pode causar downtime em rota√ß√µes futuras\n- **Mitiga√ß√£o**: Testar procedimento em staging antes de documentar","number":156,"title":"[SEC-109d] Documentar procedimento de rota√ß√£o de secrets"},{"body":"## Context\nIssue pai: #109 (desmembrada para atomicidade)\n\nAp√≥s escolher a solu√ß√£o de secrets management (#153), √© necess√°rio migrar os 5 secrets cr√≠ticos do sistema (JWT_SECRET, OPENAI_API_KEY, PERPLEXITY_API_KEY, DATABASE_URL, SESSION_SECRET) da gest√£o atual (vari√°veis de ambiente Railway) para a solu√ß√£o escolhida.\n\n## Objective\nMigrar todos os secrets do sistema para a solu√ß√£o de gest√£o escolhida, garantindo zero-downtime e validando que a aplica√ß√£o funciona corretamente ap√≥s migra√ß√£o.\n\n## File Location\n**Arquivos a modificar:**\n- `backend/src/config/secrets.service.ts` (criar - servi√ßo de acesso a secrets)\n- `backend/src/config/config.module.ts` (modificar - integrar SecretsService)\n- `backend/src/auth/auth.module.ts` (modificar - usar SecretsService para JWT_SECRET)\n- `backend/src/orchestrator/orchestrator.service.ts` (modificar - usar SecretsService para API keys)\n- `package.json` (backend) (modificar - adicionar SDK da solu√ß√£o escolhida)\n- `.env.example` (modificar - documentar novos par√¢metros)\n- `docs/SECRETS_MANAGEMENT.md` (criar - documentar uso)\n\n## Technical Approach\n\n### Passo 1: Instalar SDK da solu√ß√£o escolhida\n```bash\ncd backend\n\n# Se AWS Secrets Manager:\nnpm install @aws-sdk/client-secrets-manager\n\n# Se Vault:\nnpm install node-vault\n```\n\n### Passo 2: Criar SecretsService\nCriar `backend/src/config/secrets.service.ts`:\n```typescript\nimport { Injectable, Logger } from '@nestjs/common';\n// Import SDK conforme solu√ß√£o escolhida\n\n@Injectable()\nexport class SecretsService {\n  private readonly logger = new Logger(SecretsService.name);\n  private cache: Map<string, { value: string; expiresAt: number }> = new Map();\n\n  async getSecret(name: string): Promise<string> {\n    // Verificar cache (TTL: 5 minutos)\n    const cached = this.cache.get(name);\n    if (cached && cached.expiresAt > Date.now()) {\n      return cached.value;\n    }\n\n    // Buscar do secrets manager\n    this.logger.log(`Fetching secret: ${name}`);\n    const value = await this.fetchFromProvider(name);\n\n    // Cachear\n    this.cache.set(name, {\n      value,\n      expiresAt: Date.now() + 5 * 60 * 1000, // 5min\n    });\n\n    return value;\n  }\n\n  private async fetchFromProvider(name: string): Promise<string> {\n    // Implementar conforme solu√ß√£o escolhida\n    throw new Error('Not implemented');\n  }\n}\n```\n\n### Passo 3: Integrar no AuthModule (JWT_SECRET)\nModificar `backend/src/auth/auth.module.ts`:\n```typescript\n// Antes:\nJwtModule.register({\n  secret: process.env.JWT_SECRET,\n})\n\n// Depois:\nJwtModule.registerAsync({\n  inject: [SecretsService],\n  useFactory: async (secrets: SecretsService) => ({\n    secret: await secrets.getSecret('JWT_SECRET'),\n  }),\n})\n```\n\n### Passo 4: Integrar no OrchestratorService (API keys)\nModificar `backend/src/orchestrator/orchestrator.service.ts`:\n```typescript\n// Antes:\nconst apiKey = process.env.OPENAI_API_KEY;\n\n// Depois:\nconst apiKey = await this.secretsService.getSecret('OPENAI_API_KEY');\n```\n\n### Passo 5: Migrar secrets no Railway\n1. Adicionar credenciais da solu√ß√£o escolhida (ex: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY)\n2. Criar secrets no secrets manager com valores atuais\n3. Validar que aplica√ß√£o consegue buscar secrets\n4. Remover secrets antigos das vari√°veis Railway (ap√≥s valida√ß√£o)\n\n### Passo 6: Testes de valida√ß√£o\n```bash\n# Testar login (valida JWT_SECRET)\ncurl -X POST http://localhost:3000/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\":\"user@example.com\",\"password\":\"password123\"}'\n\n# Testar gera√ß√£o de se√ß√£o (valida OPENAI_API_KEY)\ncurl -X POST http://localhost:3000/sections/etp/1/generate \\\n  -H \"Authorization: Bearer <token>\"\n```\n\n## Acceptance Criteria\n- [ ] SecretsService criado e integrado no ConfigModule\n- [ ] JWT_SECRET migrado (autentica√ß√£o funciona)\n- [ ] OPENAI_API_KEY migrado (gera√ß√£o de se√ß√£o funciona)\n- [ ] PERPLEXITY_API_KEY migrado\n- [ ] DATABASE_URL migrado (conex√£o DB funciona)\n- [ ] SESSION_SECRET migrado\n- [ ] Testes validam que aplica√ß√£o funciona com secrets do manager\n- [ ] Documenta√ß√£o de uso criada em `docs/SECRETS_MANAGEMENT.md`\n\n## Dependencies\n- **Blocked by**: #153 (#109a - decis√£o de qual solu√ß√£o usar)\n- **Blocks**: #109e (dual-key strategy depende da migra√ß√£o estar feita)\n- **Related**: #109 (issue pai)\n\n## Estimated Effort\n‚è±Ô∏è **4 horas** (implementa√ß√£o + testes + valida√ß√£o)\n\n## Risk\nüî¥ **ALTO** - Erro na migra√ß√£o pode derrubar autentica√ß√£o ou gera√ß√£o de ETPs em produ√ß√£o\n- **Mitiga√ß√£o**: Testar em ambiente de staging primeiro\n- **Rollback**: Manter secrets antigos no Railway at√© valida√ß√£o completa","number":155,"title":"[SEC-109c] Migrar secrets para solu√ß√£o de gest√£o escolhida"},{"body":"## Contexto\n\nIssue #85 auditou **OWASP Top 10** (vulnerabilidades conhecidas), mas **penetration testing** descobre vulnerabilidades desconhecidas.\n\n**Risco Alto:** Zero-day vulnerability descoberta p√≥s-lan√ßamento = breach.\n\n## Problema\n\n- ‚ùå Apenas auditoria interna (vi√©s de confirma√ß√£o)\n- ‚ùå Sem testes de invas√£o (pentest)\n- ‚ùå Sem bug bounty program\n- ‚ùå Sem vulnerability disclosure policy\n\n## Objetivo\n\nContratar **pentester terceirizado** e estabelecer **vulnerability disclosure policy**.\n\n## Crit√©rios de Aceita√ß√£o\n\n### 1. Hire Third-Party Penetration Tester\n\n**Escopo do Pentest:**\n- [ ] Web application (frontend + backend)\n- [ ] API endpoints (authentication, authorization)\n- [ ] Database security (SQL injection, access control)\n- [ ] Infrastructure (Railway, PostgreSQL)\n- [ ] Social engineering (phishing attempt?)\n\n**Deliverables:**\n- [ ] Penetration test report (vulnerabilities found)\n- [ ] CVSS scores for each vulnerability\n- [ ] Remediation recommendations\n- [ ] Retest ap√≥s fixes implementados\n\n**Recommended Vendors:**\n- Offensive Security (OSCP certified)\n- HackerOne managed pentests\n- BugCrowd (pentest + bug bounty)\n- Local cybersecurity firms (Brazil-based)\n\n### 2. Vulnerability Remediation\n\n- [ ] Triage vulnerabilities by CVSS score\n- [ ] Fix CRITICAL (CVSS 9-10) within 7 days\n- [ ] Fix HIGH (CVSS 7-8.9) within 30 days\n- [ ] Fix MEDIUM (CVSS 4-6.9) within 90 days\n- [ ] Document LOW (CVSS 0-3.9) - accept risk or fix later\n\n### 3. Retest & Validation\n\n- [ ] Pentester retests fixes\n- [ ] Validate all CRITICAL/HIGH are resolved\n- [ ] Issue pentest certificate (if applicable)\n\n### 4. Bug Bounty Program (Optional)\n\n**If budget allows:**\n- [ ] Launch bug bounty on HackerOne or BugCrowd\n- [ ] Define scope (in-scope vs out-of-scope)\n- [ ] Define rewards:\n  - Critical: $500-1000\n  - High: $200-500\n  - Medium: $50-200\n  - Low: $0-50 (acknowledgment)\n\n**Benefits:**\n- Continuous security testing\n- Community engagement\n- Cost-effective vs full-time pentest\n\n### 5. Vulnerability Disclosure Policy\n\nCreate `SECURITY.md` with:\n- [ ] How to report vulnerabilities (email: security@etp-express.com)\n- [ ] What to expect (acknowledgment within 48h, fix within 90 days)\n- [ ] Safe harbor (won't prosecute ethical hackers)\n- [ ] Hall of Fame (acknowledge researchers)\n\n**Example SECURITY.md:**\n```markdown\n# Security Policy\n\n## Reporting a Vulnerability\n\nIf you discover a security vulnerability, please email security@etp-express.com\n\n**Please include:**\n- Description of the vulnerability\n- Steps to reproduce\n- Potential impact\n- Your contact information (for acknowledgment)\n\n**We commit to:**\n- Acknowledge within 48 hours\n- Provide status updates every 7 days\n- Fix CRITICAL issues within 7 days\n- Fix HIGH issues within 30 days\n\n## Safe Harbor\n\nWe will not pursue legal action against researchers who:\n- Report vulnerabilities responsibly\n- Do not exploit vulnerabilities beyond proof-of-concept\n- Do not access/modify user data\n\n## Hall of Fame\n\nWe publicly acknowledge researchers who help us improve security.\n```\n\n### 6. Security Awareness Training\n\n- [ ] Train team on secure coding practices\n- [ ] Train team on incident response\n- [ ] Regular security reviews (quarterly)\n\n## Risco\n\nüî¥ **ALTO** - Vulnerabilidades desconhecidas = risco de breach\n\n## Estimativa\n\n‚è±Ô∏è 20-24 horas (mostly vendor time, 4-6h internal)\n\n**Cost Estimate:**\n- Pentest: $2,000-5,000 USD\n- Bug Bounty: $500-2,000/month (optional)\n\n## Milestone\n\nM3: Quality & Security","number":114,"title":"[SEC] Third-Party Penetration Testing & Vulnerability Disclosure"},{"body":"## Contexto\n\nIssue #86 audita **conformidade LGPD**, issue #87 implementa **remedia√ß√µes**, mas **exporta√ß√£o e dele√ß√£o de dados n√£o s√£o automatizadas**.\n\n**Risco Alto:** Viola√ß√£o LGPD se processo manual n√£o escalar.\n\n## Problema (LGPD Requirements)\n\nConforme LGPD, usu√°rios t√™m direito a:\n1. **Portabilidade:** Exportar todos os seus dados\n2. **Esquecimento:** Deletar permanentemente todos os seus dados\n3. **Transpar√™ncia:** Saber quais dados s√£o coletados\n\nAtualmente:\n- ‚ùå Exporta√ß√£o de dados √© manual (DBA precisa rodar query SQL)\n- ‚ùå Dele√ß√£o n√£o √© em cascata (deixa dados √≥rf√£os)\n- ‚ùå Audit trail incompleto\n\n## Objetivo\n\nAutomatizar **portabilidade** e **esquecimento** conforme LGPD.\n\n## Crit√©rios de Aceita√ß√£o\n\n### 1. Data Export API (Portabilidade)\n\n**Endpoint:** GET /api/users/me/export\n\n- [ ] Retorna JSON com TODOS os dados do usu√°rio:\n  - User profile\n  - All ETPs created\n  - All sections generated\n  - All versions/history\n  - Analytics events\n  - Audit logs\n- [ ] Formato: JSON estruturado\n- [ ] Opcionalmente: CSV, PDF\n- [ ] Gerar zip se > 10MB\n\n**Exemplo response:**\n```json\n{\n  \"user\": { \"id\": 1, \"email\": \"user@example.com\", ... },\n  \"etps\": [ { \"id\": 1, \"title\": \"...\", \"sections\": [...] } ],\n  \"analytics\": [ { \"event\": \"section_generated\", \"timestamp\": \"...\" } ],\n  \"audit_logs\": [ { \"action\": \"login\", \"timestamp\": \"...\" } ]\n}\n```\n\n### 2. Account Deletion API (Esquecimento)\n\n**Endpoint:** DELETE /api/users/me\n\n- [ ] Dele√ß√£o em cascata (todas as tabelas relacionadas):\n  - `DELETE FROM analytics WHERE user_id = X`\n  - `DELETE FROM versions WHERE etp_id IN (SELECT id FROM etps WHERE user_id = X)`\n  - `DELETE FROM sections WHERE etp_id IN (SELECT id FROM etps WHERE user_id = X)`\n  - `DELETE FROM etps WHERE user_id = X`\n  - `DELETE FROM audit_logs WHERE user_id = X`\n  - `DELETE FROM users WHERE id = X`\n- [ ] Soft delete primeiro (flag `deleted_at`)\n- [ ] Hard delete ap√≥s 30 dias (retention policy)\n- [ ] Email de confirma√ß√£o antes de deletar\n- [ ] Imposs√≠vel reverter ap√≥s confirma√ß√£o\n\n### 3. Data Retention Policy\n\n- [ ] Dados de usu√°rio ativo: Sem limite\n- [ ] Dados de usu√°rio inativo (>1 ano sem login): Notificar antes de deletar\n- [ ] Dados de usu√°rio deletado (soft): 30 dias\n- [ ] Dados de usu√°rio deletado (hard): Permanentemente removido ap√≥s 30 dias\n- [ ] Analytics agregados: Anonimizados (user_id ‚Üí NULL)\n\n### 4. Audit Trail for Compliance\n\n- [ ] Log de data exports (quem, quando, o qu√™)\n- [ ] Log de account deletions (quem, quando, confirmado?)\n- [ ] Log de data retention purges (automated)\n\n### 5. Privacy Policy & Terms Update\n\n- [ ] Atualizar PRIVACY_POLICY.md com:\n  - Dados coletados\n  - Como s√£o usados\n  - Direitos do usu√°rio (export, delete)\n  - Retention policy\n- [ ] Link vis√≠vel no footer do site\n\n### 6. Testing\n\n- [ ] Test data export (verify completeness)\n- [ ] Test account deletion (verify cascade)\n- [ ] Test retention policy (automated purge)\n\n## Risco\n\nüî¥ **ALTO** - N√£o compliance LGPD = multas (at√© 2% do faturamento)\n\n## Estimativa\n\n‚è±Ô∏è 10-12 horas\n\n## Depend√™ncias\n\n- **Recomendado:** #86 (LGPD audit should identify gaps)\n- **Recomendado:** #87 (LGPD remediations)\n\n## Milestone\n\nM3: Quality & Security","number":113,"title":"[LGPD] Data Export & Deletion Automation for Compliance"},{"body":"## Contexto\n\nUAT plan existe (#92-#95), mas **n√£o h√° equipe de suporte treinada** nem SLA definido.\n\n**Risco Alto:** Primeiro problema em produ√ß√£o = usu√°rios sem ajuda.\n\n## Problema\n\n- ‚ùå Sem SLA (uptime, response time, resolution time)\n- ‚ùå Sem equipe de suporte treinada\n- ‚ùå Sem ferramentas de suporte (ticketing system)\n- ‚ùå Sem templates de comunica√ß√£o\n\n## Objetivo\n\nPreparar **equipe de suporte** e definir **SLAs** antes de go-live.\n\n## Crit√©rios de Aceita√ß√£o\n\n### SLA Definition\n\n**Uptime SLA:**\n- [ ] Target: 99.5% uptime (3.6h downtime/m√™s permitido)\n- [ ] Measurement: Status page tracking\n- [ ] Penalty: Credit to users if breached\n\n**Response Time SLA:**\n- [ ] P0 (Critical - System Down): 15 min response, 4h resolution\n- [ ] P1 (High - Major Feature Broken): 1h response, 8h resolution\n- [ ] P2 (Medium - Minor Issue): 4h response, 24h resolution\n- [ ] P3 (Low - Enhancement): 24h response, 7 days resolution\n\n**Support Hours:**\n- [ ] Business hours: 8am-6pm BRT (Mon-Fri)\n- [ ] After hours: On-call for P0 only\n- [ ] Weekends: On-call for P0 only\n\n### Support Team Training\n\n**Training Materials:**\n- [ ] Product walkthrough (criar ETPs, gerar se√ß√µes, exportar)\n- [ ] Common issues & solutions (incident playbook)\n- [ ] Escalation procedures\n- [ ] Database read-only access (troubleshooting)\n\n**Team Composition:**\n- [ ] Tier 1: First responder (2 pessoas)\n- [ ] Tier 2: Engineering escalation (3 dev)\n- [ ] Tier 3: Incident commander (1 CTO)\n\n### Support Tools\n\n- [ ] Ticketing system (Zendesk, Intercom, or custom)\n- [ ] Knowledge base (FAQ, troubleshooting guides)\n- [ ] Slack channel #user-support\n- [ ] Email support@etp-express.com\n\n### Communication Templates\n\n**Incident Templates:**\n- [ ] \"Incident detected\" (internal alert)\n- [ ] \"Incident acknowledged\" (to users)\n- [ ] \"Incident resolved\" (to users)\n- [ ] Post-mortem report (internal + public)\n\n**Support Templates:**\n- [ ] \"How to create your first ETP\"\n- [ ] \"Troubleshooting IA generation failures\"\n- [ ] \"How to export PDF\"\n\n### Metrics to Track\n\n- [ ] CSAT (Customer Satisfaction Score) - target: > 4.5/5\n- [ ] Time to First Response - target: < SLA\n- [ ] Time to Resolution - target: < SLA\n- [ ] Ticket volume (identify common issues)\n\n## Risco\n\nüî¥ **ALTO** - Usu√°rios sem suporte = abandono do sistema\n\n## Estimativa\n\n‚è±Ô∏è 6-8 horas\n\n## Milestone\n\nM5: E2E Testing & Documentation","number":111,"title":"[OPS] Production Support SLA Definition & Team Training"},{"body":"## Contexto\n\nIssues #92-#95 planejam UAT com 5 usu√°rios, mas **rollout completo acontece imediatamente ap√≥s**. N√£o h√° est√°gios intermedi√°rios.\n\n**Risco Alto:** UAT passa para 5 usu√°rios, produ√ß√£o falha para 500.\n\n## Problema\n\n- ‚ùå Binary rollout: 0% ‚Üí 100% (sem est√°gios)\n- ‚ùå Sem feature flags (n√£o pode desabilitar features remotamente)\n- ‚ùå Sem canary releases (novo c√≥digo para 1% primeiro)\n- ‚ùå Rollback requer redeploy (lento, arriscado)\n\n## Objetivo\n\nImplementar **staged rollout** com feature flags para controlar exposi√ß√£o gradual.\n\n## Crit√©rios de Aceita√ß√£o\n\n### Feature Flags System\n\nEscolher uma das op√ß√µes:\n- [ ] **Op√ß√£o 1:** LaunchDarkly (managed, free tier 100 flags)\n- [ ] **Op√ß√£o 2:** Flagsmith (open-source)\n- [ ] **Op√ß√£o 3:** Custom implementation (simples, DB-based)\n\n### Key Features to Flag\n\n- [ ] AI generation (pode desabilitar se OpenAI cair)\n- [ ] Perplexity search (pode desabilitar se rate limit)\n- [ ] PDF export (pode desabilitar se Puppeteer quebrar)\n- [ ] New UI features (A/B testing)\n\n### Staged Rollout Plan\n\n**Fase 1: Alpha (Internal)**\n- [ ] 0% ‚Üí 5% (team interno)\n- [ ] Duration: 1 semana\n- [ ] Success criteria: Zero critical bugs\n\n**Fase 2: Beta (Early Adopters)**\n- [ ] 5% ‚Üí 25% (usu√°rios beta)\n- [ ] Duration: 2 semanas\n- [ ] Success criteria: NPS > 7, error rate < 1%\n\n**Fase 3: General Availability**\n- [ ] 25% ‚Üí 50% ‚Üí 100%\n- [ ] Duration: 1 semana por est√°gio\n- [ ] Success criteria: Same metrics as Beta\n\n### Rollback Strategy\n\n- [ ] Feature flag OFF = instant rollback (no redeploy)\n- [ ] Emergency kill switch (disable all new features)\n- [ ] Graceful degradation (fallback to manual mode)\n\n### Monitoring per Stage\n\n- [ ] Error rate by rollout percentage\n- [ ] Latency by rollout percentage\n- [ ] User satisfaction by rollout percentage\n\n## Risco\n\nüî¥ **ALTO** - Rollout completo sem est√°gios = imposs√≠vel reverter rapidamente\n\n## Estimativa\n\n‚è±Ô∏è 10-12 horas\n\n## Milestone\n\nM5: E2E Testing & Documentation","number":110,"title":"[OPS] Staged Rollout Strategy & Feature Flags Implementation"},{"body":"## Contexto\n\nAtualmente, chaves API (OpenAI, Perplexity, JWT secret) **nunca s√£o rotacionadas**. Se uma chave vazar, todo o sistema fica comprometido.\n\n**Risco Alto:** API key vazada = comprometimento total do sistema.\n\n## Problema\n\n- ‚ùå Chaves armazenadas em vari√°veis de ambiente (sem rota√ß√£o)\n- ‚ùå JWT_SECRET nunca muda (se vazar, invalidar todos os tokens?)\n- ‚ùå OpenAI API key hardcoded (se vazar, custos podem explodir)\n- ‚ùå Perplexity API key sem rota√ß√£o\n- ‚ùå Database connection string n√£o rotacion√°vel\n\n## Objetivo\n\nImplementar **gest√£o segura de secrets** com rota√ß√£o autom√°tica.\n\n## Crit√©rios de Aceita√ß√£o\n\n### Secrets Management Solution\n\nEscolher uma das op√ß√µes:\n- [ ] **Op√ß√£o 1:** HashiCorp Vault (self-hosted)\n- [ ] **Op√ß√£o 2:** AWS Secrets Manager (managed)\n- [ ] **Op√ß√£o 3:** Railway Secrets (built-in, b√°sico)\n\n### Secrets a Gerenciar\n\n- [ ] JWT_SECRET (rotar mensalmente)\n- [ ] OPENAI_API_KEY (rotar trimestralmente)\n- [ ] PERPLEXITY_API_KEY (rotar trimestralmente)\n- [ ] DATABASE_URL (rotar manualmente)\n- [ ] SESSION_SECRET (rotar mensalmente)\n\n### Rotation Strategy\n\n- [ ] Documentar procedimento de rota√ß√£o para cada secret\n- [ ] Implementar zero-downtime rotation (dual-key strategy)\n- [ ] Alert 7 dias antes da expira√ß√£o\n- [ ] Automated rotation (onde poss√≠vel)\n\n### Secret Scanning\n\n- [ ] Configurar secret scanning no GitHub\n- [ ] Adicionar pre-commit hook (detect-secrets)\n- [ ] Scan hist√≥rico do git (remover secrets antigos)\n\n### Audit Trail\n\n- [ ] Log de quem acessou cada secret\n- [ ] Log de quando secrets foram rotacionados\n- [ ] Alertas de acesso an√¥malo\n\n## Dual-Key Strategy (Zero-Downtime Rotation)\n\nPara evitar downtime durante rota√ß√£o:\n\n1. **Antes:** Sistema usa KEY_1\n2. **Durante rota√ß√£o:** Sistema aceita KEY_1 OU KEY_2\n3. **Depois:** Sistema usa apenas KEY_2, remove KEY_1\n\n## Risco\n\nüî¥ **ALTO** - Chave vazada sem rota√ß√£o = comprometimento permanente\n\n## Estimativa\n\n‚è±Ô∏è 8-10 horas\n\n## Milestone\n\nM3: Quality & Security","number":109,"title":"[SEC] Secrets Management & API Key Rotation Strategy"},{"body":"## üìã Contexto\nIssue original: #48 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nAnalisar dados coletados nas sess√µes UAT e gerar relat√≥rio com insights e recomenda√ß√µes.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Consolidar dados quantitativos:\n  - Taxa de sucesso por tarefa\n  - Tempo m√©dio de execu√ß√£o\n  - NPS ou satisfa√ß√£o geral\n  - N√∫mero de bugs cr√≠ticos vs menores\n- [ ] Analisar feedback qualitativo:\n  - Temas recorrentes (padr√µes de confus√£o)\n  - Sugest√µes de melhoria mais citadas\n  - Pontos fortes do sistema\n- [ ] Priorizar issues encontrados:\n  - P0 (bloqueantes para ado√ß√£o)\n  - P1 (importantes mas workaround existe)\n  - P2 (nice to have)\n- [ ] Criar relat√≥rio final de UAT:\n  - Executive summary\n  - Metodologia\n  - Perfil dos participantes\n  - Resultados quantitativos\n  - Insights qualitativos\n  - Lista de issues priorizadas\n  - Recomenda√ß√µes de pr√≥ximos passos\n- [ ] Apresentar resultados para stakeholders\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #48c (Sess√µes devem estar conclu√≠das)\n\n## üìä Deliverables\n- Relat√≥rio final: `/docs/uat/uat-final-report.md`\n- Issues criadas no GitHub (bugs P0/P1 encontrados)\n\n## üìö Refer√™ncia\n- Dados de #48c\n","number":95,"title":"[#48d] An√°lise de resultados e relat√≥rio final de UAT"},{"body":"## üìã Contexto\nIssue original: #48 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nExecutar sess√µes de UAT com os 3-5 testadores recrutados, observando intera√ß√µes e coletando feedback.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Executar 3-5 sess√µes individuais de UAT (1-2h cada)\n- [ ] Para cada sess√£o:\n  - Seguir roteiro preparado (#48b)\n  - Observar e registrar comportamento do usu√°rio\n  - Anotar dificuldades, confus√µes, bugs encontrados\n  - Coletar feedback verbal em tempo real\n  - Aplicar question√°rio p√≥s-sess√£o\n- [ ] Registrar m√©tricas:\n  - Taxa de conclus√£o de tarefas\n  - Tempo m√©dio por tarefa\n  - N√∫mero de erros/bloqueios\n  - Satisfa√ß√£o geral (NPS ou escala 1-10)\n- [ ] Gravar sess√µes (com consentimento) para an√°lise posterior\n- [ ] Consolidar todos os feedbacks coletados\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #48b (Roteiro e agendamento devem estar prontos)\n\n## üìä Deliverables\n- Grava√ß√µes de sess√µes (se aplic√°vel)\n- Notas de observa√ß√£o\n- Question√°rios preenchidos\n- Lista de bugs/issues encontrados\n\n## üìö Refer√™ncia\n- Roteiro: `/docs/uat/session-script.md`\n- Armazenar resultados: `/docs/uat/sessions/`\n","number":94,"title":"[#48c] Execu√ß√£o de sess√µes UAT e coleta de feedback"},{"body":"## üìã Contexto\nIssue original: #48 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nPlanejar estrutura, roteiro e materiais para as sess√µes de UAT com testadores reais.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Criar roteiro de sess√£o UAT:\n  - Introdu√ß√£o e objetivo (5 min)\n  - Tarefas guiadas (30 min):\n    1. Login e navega√ß√£o inicial\n    2. Criar novo ETP do zero\n    3. Gerar se√ß√£o com LLM\n    4. Editar se√ß√£o manualmente\n    5. Validar conte√∫do\n    6. Gerar PDF final\n  - Perguntas abertas e feedback (15 min)\n  - Question√°rio de satisfa√ß√£o (10 min)\n- [ ] Preparar cen√°rios de teste:\n  - 2-3 projetos fict√≠cios para testar\n  - Dados de entrada pr√©-preparados\n- [ ] Criar question√°rio de UAT:\n  - Facilidade de uso (escala Likert)\n  - Qualidade do conte√∫do gerado\n  - Bugs encontrados\n  - Sugest√µes de melhoria\n- [ ] Preparar ambiente de teste:\n  - Deploy em staging/demo\n  - Dados de login para testadores\n- [ ] Agendar sess√µes com participantes (#48a)\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #48a (Testadores devem estar recrutados)\n\n## üìö Refer√™ncia\n- Criar: `/docs/uat/session-script.md`\n- Criar: `/docs/uat/questionnaire.md`\n","number":93,"title":"[#48b] Planejamento e roteiro de sess√µes UAT"},{"body":"## üìã Contexto\nIssue original: #48 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nRecrutar 3-5 servidores p√∫blicos reais para participar de sess√µes de UAT (User Acceptance Testing).\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Definir perfil de testadores:\n  - Cargo/fun√ß√£o (gestores de projetos, analistas t√©cnicos)\n  - N√≠vel de experi√™ncia com ETPs\n  - Disponibilidade para sess√µes de 1-2h\n- [ ] Identificar canais de recrutamento:\n  - Redes internas (CONFENGE, √≥rg√£os p√∫blicos)\n  - LinkedIn, comunidades de servidores\n- [ ] Criar convite/briefing para participantes:\n  - Objetivo do UAT\n  - Tempo necess√°rio\n  - Confidencialidade (NDA se necess√°rio)\n- [ ] Recrutar e confirmar 3-5 participantes\n- [ ] Coletar dados de contato e disponibilidade\n\n## üéØ Meta\nM√≠nimo 3, ideal 5 testadores confirmados\n\n## üìö Refer√™ncia\n- Criar documento: `/docs/uat/recruiter-brief.md`\n","number":92,"title":"[#48a] Recrutamento de 3-5 testadores (servidores p√∫blicos)"},{"body":"## üìã Contexto\nIssue original: #47 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nImplementar corre√ß√µes de performance para resolver bottlenecks identificados na an√°lise (#47c).\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Aguardar conclus√£o de #47c (an√°lise de bottlenecks)\n- [ ] Priorizar otimiza√ß√µes por impacto (maior ganho primeiro)\n- [ ] Implementar otimiza√ß√µes comuns:\n  - Caching (Redis para dados frequentes)\n  - Connection pooling (DB, HTTP)\n  - Indexa√ß√£o de banco de dados\n  - Compress√£o de respostas (gzip)\n  - Lazy loading / pagina√ß√£o\n  - Rate limiting inteligente\n  - Worker threads para tarefas pesadas\n- [ ] Re-executar load tests (#47b) para validar melhorias\n- [ ] Comparar m√©tricas antes/depois\n- [ ] Documentar otimiza√ß√µes aplicadas\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #47c (An√°lise deve identificar o que otimizar)\n\n## üéØ Meta de Performance\n- Lat√™ncia p95 < 500ms (endpoints normais)\n- Lat√™ncia p95 < 3s (gera√ß√£o LLM)\n- Suportar 100+ usu√°rios simult√¢neos sem degrada√ß√£o\n\n## üìö Refer√™ncia\n- Relat√≥rio de #47c\n- C√≥digo: Conforme bottlenecks identificados\n","number":91,"title":"[#47d] Implementar otimiza√ß√µes de performance identificadas"},{"body":"## üìã Contexto\nIssue original: #47 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nIdentificar gargalos de performance atrav√©s de an√°lise de m√©tricas e profiling de c√≥digo.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Analisar relat√≥rio de load testing (#47b)\n- [ ] Identificar endpoints com maior lat√™ncia\n- [ ] Executar profiling de aplica√ß√£o:\n  - Node.js --inspect (Chrome DevTools)\n  - clinic.js (bubbleprof, flame, doctor)\n- [ ] Analisar queries lentas no banco de dados\n- [ ] Verificar gargalos de I/O (LLM API, file system)\n- [ ] Identificar memory leaks ou vazamentos de recursos\n- [ ] Gerar lista priorizada de bottlenecks para otimizar\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #47b (Testes devem estar executados)\n\n## üõ†Ô∏è Ferramentas de Profiling\n- Node.js --inspect + Chrome DevTools\n- clinic.js (npm install -g clinic)\n- APM tools (New Relic, Datadog, se dispon√≠vel)\n\n## üìö Refer√™ncia\n- Resultados de #47b\n- C√≥digo: Backend completo\n","number":90,"title":"[#47c] An√°lise de bottlenecks e profiling de performance"},{"body":"## üìã Contexto\nIssue original: #47 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nExecutar testes de carga progressivos para identificar limite de capacidade do sistema.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Executar testes com rampa de carga:\n  - 10 VUs (Virtual Users) por 5 min (baseline)\n  - 50 VUs por 10 min\n  - 100 VUs por 15 min\n  - 200 VUs por 10 min (stress test)\n- [ ] Coletar m√©tricas:\n  - Lat√™ncia (p50, p95, p99)\n  - Throughput (req/s)\n  - Taxa de erro (%)\n  - Uso de recursos (CPU, RAM, DB connections)\n- [ ] Identificar ponto de quebra (quando sistema degrada)\n- [ ] Gerar relat√≥rio de resultados\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #47a (Setup deve estar pronto)\n\n## üìä Cen√°rios de Teste\n1. Autentica√ß√£o massiva (100 logins simult√¢neos)\n2. Gera√ß√£o de ETPs concorrentes (50 ETPs em paralelo)\n3. Gera√ß√£o de se√ß√µes com LLM (teste de rate limit OpenAI)\n\n## üìö Refer√™ncia\n- C√≥digo: `/tests/load/`\n","number":89,"title":"[#47b] Executar testes de carga para 100+ usu√°rios simult√¢neos"},{"body":"## üìã Contexto\nIssue original: #47 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nConfigurar ambiente de testes de carga para validar capacidade do sistema em suportar 100+ usu√°rios simult√¢neos.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Avaliar ferramentas: k6, Artillery, JMeter, Locust\n- [ ] Selecionar ferramenta (recomenda√ß√£o: k6 para facilidade + scripts JS)\n- [ ] Instalar e configurar ambiente de load testing\n- [ ] Criar scripts base de teste para endpoints cr√≠ticos:\n  - POST /auth/login\n  - POST /etps (criar ETP)\n  - POST /sections/etp/:id/generate (gera√ß√£o com LLM)\n- [ ] Configurar m√©tricas de observa√ß√£o (lat√™ncia, throughput, erros)\n- [ ] Documentar setup e uso\n\n## üõ†Ô∏è Ferramentas Sugeridas\n- **k6** (Grafana): Scripts em JS, output JSON, integra√ß√£o Grafana Cloud\n- **Artillery**: YAML config, f√°cil CI/CD\n- **JMeter**: GUI, mais pesado mas robusto\n\n## üìö Refer√™ncia\n- https://k6.io/docs/\n- C√≥digo: Criar `/tests/load/`\n","number":88,"title":"[#47a] Setup ambiente de load testing (k6 ou Artillery)"},{"body":"## üìã Contexto\nIssue original: #46 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nImplementar corre√ß√µes de seguran√ßa identificadas nas auditorias #46a (OWASP) e #46b (LGPD).\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Aguardar conclus√£o de #46a e #46b (issues bloqueantes)\n- [ ] Priorizar corre√ß√µes por severidade (CRITICAL ‚Üí HIGH ‚Üí MEDIUM)\n- [ ] Implementar corre√ß√µes de vulnerabilidades OWASP\n- [ ] Implementar ajustes de conformidade LGPD\n- [ ] Executar testes de regress√£o (garantir que corre√ß√µes n√£o quebraram nada)\n- [ ] Atualizar documenta√ß√£o de seguran√ßa\n- [ ] Re-executar auditorias para validar corre√ß√µes\n\n## ‚ö†Ô∏è Depend√™ncias\n**Bloqueada por**: #46a, #46b (Auditorias devem ser conclu√≠das primeiro)\n\n## üìö Refer√™ncia\n- Relat√≥rios de #46a e #46b\n- C√≥digo: Conforme issues identificadas\n","number":87,"title":"[#46c] Implementar remedia√ß√µes de seguran√ßa identificadas"},{"body":"## üìã Contexto\nIssue original: #46 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nGarantir conformidade com **LGPD** (Lei Geral de Prote√ß√£o de Dados) e boas pr√°ticas de privacidade.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Mapear fluxo de dados pessoais (coleta, armazenamento, processamento)\n- [ ] Verificar consentimento de usu√°rios (termos, pol√≠ticas)\n- [ ] Implementar anonimiza√ß√£o/pseudonimiza√ß√£o onde aplic√°vel\n- [ ] Validar criptografia de dados sens√≠veis (em tr√¢nsito e repouso)\n- [ ] Revisar pol√≠tica de reten√ß√£o de dados\n- [ ] Verificar direitos do titular (acesso, corre√ß√£o, exclus√£o)\n- [ ] Implementar logs de auditoria (quem acessou o qu√™)\n- [ ] Criar pol√≠tica de privacidade e termos de uso\n- [ ] Gerar relat√≥rio de conformidade\n\n## üìö Refer√™ncia\n- LGPD (Lei 13.709/2018)\n- C√≥digo: src/auth/, src/users/, src/etps/\n","number":86,"title":"[#46b] Auditoria de conformidade: LGPD e privacidade de dados"},{"body":"## üìã Contexto\nIssue original: #43 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nTestar a gera√ß√£o das se√ß√µes finais 9-13 do ETP:\n9. **Cronograma de Execu√ß√£o**\n10. **Indicadores de Desempenho (KPIs)**\n11. **An√°lise de Riscos**\n12. **Plano de Sustentabilidade**\n13. **Anexos e Refer√™ncias**\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Testar gera√ß√£o de cada se√ß√£o individualmente\n- [ ] Validar cronograma (datas, marcos, depend√™ncias)\n- [ ] Verificar KPIs (m√©tricas SMART)\n- [ ] Testar an√°lise de riscos (identifica√ß√£o, mitiga√ß√£o)\n- [ ] Validar gera√ß√£o de anexos\n- [ ] Documentar bugs ou problemas encontrados\n\n## üß™ Casos de Teste\n- Cronogramas curtos (3 meses) e longos (2+ anos)\n- Projetos de alto risco vs baixo risco\n- Diferentes tipos de anexos\n\n## üìö Refer√™ncia\n- C√≥digo: `src/sections/`\n- Subagentes: PlanoTrabalho, Cronograma\n","number":84,"title":"[#43c] Testar gera√ß√£o se√ß√µes 9-13 (Cronograma, Indicadores, Riscos, Sustentabilidade, Anexos)"},{"body":"## üìã Contexto\nIssue original: #43 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nTestar a gera√ß√£o das se√ß√µes 5-8 do ETP:\n5. **Justificativa T√©cnica**\n6. **P√∫blico-Alvo e Benefici√°rios**\n7. **Or√ßamento Estimado**\n8. **Metodologia de Execu√ß√£o**\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Testar gera√ß√£o de cada se√ß√£o individualmente\n- [ ] Validar precis√£o dos c√°lculos (or√ßamento)\n- [ ] Verificar consist√™ncia entre se√ß√µes relacionadas\n- [ ] Testar regenera√ß√£o com diferentes par√¢metros\n- [ ] Documentar bugs ou problemas encontrados\n\n## üß™ Casos de Teste\n- Or√ßamentos variados (pequeno, m√©dio, grande)\n- Diferentes metodologias (√°gil, cascata, h√≠brido)\n- P√∫blicos-alvo diversos\n\n## üìö Refer√™ncia\n- C√≥digo: `src/sections/`\n- Subagentes: Justificativa, Or√ßamento, Metodologia\n","number":83,"title":"[#43b] Testar gera√ß√£o se√ß√µes 5-8 (Justificativa, Benefici√°rios, Or√ßamento, Metodologia)"},{"body":"## üìã Contexto\nIssue original: #43 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nTestar a gera√ß√£o das primeiras 4 se√ß√µes do ETP:\n1. **Identifica√ß√£o do Projeto**\n2. **Contexto e Justificativa**\n3. **Defini√ß√£o do Problema**\n4. **Objetivos (Geral e Espec√≠ficos)**\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Testar gera√ß√£o de cada se√ß√£o individualmente\n- [ ] Validar conte√∫do gerado (coer√™ncia, formato, tamanho)\n- [ ] Verificar tratamento de erros (timeout, API down)\n- [ ] Testar regenera√ß√£o de se√ß√µes\n- [ ] Documentar bugs ou problemas encontrados\n\n## üß™ Casos de Teste\n- Inputs v√°lidos (diversos contextos de projetos)\n- Inputs inv√°lidos (campos vazios, caracteres especiais)\n- Testes de carga (m√∫ltiplas gera√ß√µes simult√¢neas)\n\n## üìö Refer√™ncia\n- C√≥digo: `src/sections/`\n- API: POST /sections/etp/:id/generate\n","number":82,"title":"[#43a] Testar gera√ß√£o se√ß√µes 1-4 (Identifica√ß√£o, Contexto, Problema, Objetivos)"},{"body":"## üìã Contexto\nIssue original: #42 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nVerificar se o m√≥dulo **User** (usu√°rios, roles, permiss√µes) est√° implementado conforme especificado no ARCHITECTURE.md.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Verificar modelo User (campos, roles, timestamps)\n- [ ] Validar UsersController (CRUD)\n- [ ] Confirmar UsersService (l√≥gica de neg√≥cio)\n- [ ] Verificar sistema de permiss√µes (RBAC)\n- [ ] Documentar desvios encontrados\n\n## üìö Refer√™ncia\n- ARCHITECTURE.md se√ß√µes: User Management, Authorization\n- C√≥digo: `src/users/`\n","number":81,"title":"[#42e] Auditar m√≥dulo User contra ARCHITECTURE.md"},{"body":"## üìã Contexto\nIssue original: #42 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nVerificar se o m√≥dulo **Orchestrator** (coordena√ß√£o de subagentes) est√° implementado conforme especificado no ARCHITECTURE.md.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Verificar orquestra√ß√£o dos 5 subagentes\n- [ ] Validar estrat√©gia de fallback/retry\n- [ ] Confirmar rate limiting e throttling\n- [ ] Verificar logging e telemetria\n- [ ] Documentar desvios encontrados\n\n## üìö Refer√™ncia\n- ARCHITECTURE.md se√ß√µes: Orchestrator Pattern, Subagents\n- C√≥digo: `src/orchestrator/` (se existir)\n","number":80,"title":"[#42d] Auditar m√≥dulo Orchestrator contra ARCHITECTURE.md"},{"body":"## üìã Contexto\nIssue original: #42 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nVerificar se o m√≥dulo **Sections** (se√ß√µes do ETP, controller, service) est√° implementado conforme especificado no ARCHITECTURE.md.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Verificar modelo Section (campos, status, valida√ß√µes)\n- [ ] Validar SectionsController (7 endpoints)\n- [ ] Confirmar SectionsService (gera√ß√£o, valida√ß√£o, regenera√ß√£o)\n- [ ] Verificar integra√ß√£o com LLM (OpenAI)\n- [ ] Documentar desvios encontrados\n\n## üìö Refer√™ncia\n- ARCHITECTURE.md se√ß√µes: Sections API, LLM Integration\n- C√≥digo: `src/sections/`\n","number":79,"title":"[#42c] Auditar m√≥dulo Sections contra ARCHITECTURE.md"},{"body":"## üìã Contexto\nIssue original: #42 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nVerificar se o m√≥dulo **ETPs** (entidades, controller, service) est√° implementado conforme especificado no ARCHITECTURE.md.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Verificar modelo ETP (campos, rela√ß√µes, valida√ß√µes)\n- [ ] Validar EtpsController (endpoints RESTful)\n- [ ] Confirmar EtpsService (l√≥gica de neg√≥cio)\n- [ ] Verificar DTOs (CreateEtpDto, UpdateEtpDto)\n- [ ] Documentar desvios encontrados\n\n## üìö Refer√™ncia\n- ARCHITECTURE.md se√ß√µes: Modelos, API Endpoints\n- C√≥digo: `src/etps/`\n","number":78,"title":"[#42b] Auditar m√≥dulo ETPs contra ARCHITECTURE.md"},{"body":"## üìã Contexto\nIssue original: #42 (desmembrada em sub-issues at√¥micas)\n\n## üéØ Objetivo\nVerificar se o m√≥dulo **Auth** (authentication, authorization, JWT) est√° implementado conforme especificado no ARCHITECTURE.md.\n\n## ‚úÖ Crit√©rios de Aceita√ß√£o\n- [ ] Verificar guards (JwtAuthGuard, RolesGuard) contra especifica√ß√£o\n- [ ] Validar estrat√©gia JWT (validade token, refresh)\n- [ ] Confirmar decorators (@CurrentUser, @Public)\n- [ ] Verificar endpoints de login/logout\n- [ ] Documentar desvios encontrados\n\n## üìö Refer√™ncia\n- ARCHITECTURE.md se√ß√µes: Autentica√ß√£o, Guards, Decorators\n- C√≥digo: `src/auth/`\n\n## üè∑Ô∏è Tipo\n- Auditoria/Valida√ß√£o\n- Milestone: M4\n","number":77,"title":"[#42a] Auditar m√≥dulo Auth contra ARCHITECTURE.md"},{"body":"## Descri√ß√£o\nConforme boas pr√°ticas de seguran√ßa, depend√™ncias desatualizadas devem ser atualizadas regularmente.\n\n## Tarefas Backend\n- [ ] cd backend\n- [ ] npm outdated (revisar lista)\n- [ ] npm update\n- [ ] npm audit fix\n- [ ] Revisar BREAKING CHANGES em changelogs\n- [ ] Rodar TODOS os testes\n- [ ] Garantir build passa\n\n## Tarefas Frontend\n- [ ] cd frontend\n- [ ] npm outdated (revisar lista)\n- [ ] npm update\n- [ ] npm audit fix\n- [ ] Revisar BREAKING CHANGES\n- [ ] Rodar testes\n- [ ] Garantir build passa\n\n## P√≥s-atualiza√ß√£o\n- [ ] Testar aplica√ß√£o manualmente em dev\n- [ ] Verificar que n√£o h√° warnings de build\n\n## Arquivos Afetados\n- backend/package.json e package-lock.json\n- frontend/package.json e package-lock.json\n- C√≥digo que usa APIs modificadas (se houver)\n\n## Crit√©rio de Sucesso\n- npm audit retorna 0 vulnerabilidades\n- Todos os testes passam\n- Aplica√ß√£o funciona identicamente","number":40,"title":"[Depend√™ncias] Atualizar depend√™ncias desatualizadas (backend e frontend)"},{"body":"## Descri√ß√£o\nO ARCHITECTURE.md menciona testes (linha 596-615) mas a se√ß√£o est√° incompleta. Deve documentar a estrat√©gia completa.\n\n## Pr√©-requisito\nIssues #1-#24 devem estar conclu√≠das\n\n## Tarefas\n- [ ] Expandir se√ß√£o \"12. TESTES\" no ARCHITECTURE.md\n- [ ] Documentar pir√¢mide de testes implementada\n- [ ] Detalhar testes unit√°rios (backend e frontend)\n- [ ] Detalhar testes de integra√ß√£o\n- [ ] Detalhar testes E2E (Puppeteer)\n- [ ] Documentar CI/CD\n- [ ] Adicionar se√ß√£o \"Rodando Testes Localmente\"\n- [ ] Adicionar se√ß√£o \"Debugging Testes\"\n\n## Arquivos Afetados\n- ARCHITECTURE.md (se√ß√£o 12)\n\n## Crit√©rio de Sucesso\n- Se√ß√£o de testes completa e detalhada\n- Comandos corretos\n- Estrat√©gia clara","number":37,"title":"[Docs] Documentar estrat√©gia de testes no ARCHITECTURE.md"},{"body":"## Descri√ß√£o\nAp√≥s implementar testes e CI, o README deve exibir badges de status e incluir instru√ß√µes de testes.\n\n## Pr√©-requisito\nIssues #1-#20 devem estar conclu√≠das\n\n## Tarefas\n- [ ] Adicionar badges no topo: CI Status, Tests, Coverage, License\n- [ ] Adicionar se√ß√£o \"Testes\" com instru√ß√µes backend\n- [ ] Adicionar instru√ß√µes frontend\n- [ ] Adicionar instru√ß√µes E2E\n- [ ] Adicionar se√ß√£o \"Contribuindo\" com checklist de PR\n- [ ] Atualizar CONTRIBUTING.md (criar se n√£o existir)\n\n## Exemplo de Badge\n```markdown\n![CI Status](https://github.com/user/repo/workflows/CI/badge.svg)\n```\n\n## Arquivos Afetados\n- README.md\n- CONTRIBUTING.md (criar ou modificar)\n\n## Crit√©rio de Sucesso\n- Badges exibem status correto\n- Instru√ß√µes de teste funcionam\n- Documenta√ß√£o completa","number":36,"title":"[Docs] Atualizar README com badges de CI, coverage e instru√ß√µes de teste"},{"body":"## Descri√ß√£o\n3 ocorr√™ncias de console.error no c√≥digo podem vazar informa√ß√µes sens√≠veis em produ√ß√£o.\n\n## Ocorr√™ncias\n- frontend/src/lib/api.ts:39\n- frontend/src/store/etpStore.ts:265\n- frontend/src/components/common/ErrorBoundary.tsx:27\n\n## Tarefas\n- [ ] Instalar winston: npm install winston\n- [ ] Criar frontend/src/lib/logger.ts\n- [ ] Configurar transporte para console (dev) e HTTP/Sentry (prod)\n- [ ] Substituir console.error por logger.error em api.ts\n- [ ] Substituir console.error por logger.error em etpStore.ts\n- [ ] Substituir console.error por logger.error em ErrorBoundary.tsx\n- [ ] Adicionar transporte para Sentry (opcional)\n\n## Arquivos Afetados\n- frontend/src/lib/logger.ts (criar)\n- frontend/src/lib/api.ts\n- frontend/src/store/etpStore.ts\n- frontend/src/components/common/ErrorBoundary.tsx\n\n## Crit√©rio de Sucesso\n- Busca por console.error no frontend retorna 0\n- Logs estruturados aparecem em dev\n- Em prod, logs enviados para servi√ßo externo","number":35,"title":"[Frontend][Observabilidade] Substituir console.error por logging service"},{"body":"## Descri√ß√£o\nO m√≥dulo orquestrador √© o mais complexo do sistema, mas n√£o possui JSDoc/TSDoc em suas fun√ß√µes.\n\n## Tarefas\n- [ ] Adicionar JSDoc em orchestrator.service.ts:\n  - generateSection()\n  - validateContent()\n  - buildSystemPrompt()\n- [ ] Adicionar JSDoc em cada agente (validate/analyze/check)\n- [ ] Documentar algoritmo de scoring de cada agente\n- [ ] Documentar warnings retornados\n- [ ] Configurar declaration: true no tsconfig.json\n- [ ] Gerar documenta√ß√£o HTML com TypeDoc (opcional)\n\n## Exemplo\n```typescript\n/**\n * Gera conte√∫do de uma se√ß√£o do ETP usando orquestra√ß√£o multi-agente.\n * \n * Pipeline de 10 etapas...\n * \n * @param context - Contexto da se√ß√£o\n * @param etpData - Dados do ETP\n * @returns Resultado completo com valida√ß√µes\n * @throws {Error} Se OpenAI API falhar\n */\n```\n\n## Arquivos Afetados\n- backend/src/modules/orchestrator/orchestrator.service.ts\n- backend/src/modules/orchestrator/agents/*.ts\n- backend/tsconfig.json\n\n## Crit√©rio de Sucesso\n- Todas as fun√ß√µes p√∫blicas t√™m JSDoc\n- VSCode mostra tooltips ao hover\n- TypeDoc gera HTML sem erros (se config)","number":34,"title":"[Docs] Adicionar JSDoc completo em OrchestratorService e agentes"},{"body":"## Descri√ß√£o\nO array SECTION_TEMPLATES (types/etp.ts linhas 104-358) possui 255 linhas hard-coded em TypeScript. Dificulta manuten√ß√£o.\n\n## Tarefas\n- [ ] Criar frontend/public/data/section-templates.json\n- [ ] Migrar todas as 13 se√ß√µes para JSON\n- [ ] Criar frontend/src/lib/section-templates.ts com interface\n- [ ] Remover defini√ß√£o antiga de types/etp.ts (linhas 104-358)\n- [ ] Atualizar todos os imports\n- [ ] Validar que aplica√ß√£o funciona identicamente\n\n## Benef√≠cios\n- Se√ß√µes edit√°veis sem recompilar\n- Mais f√°cil criar varia√ß√µes (templates por √≥rg√£o)\n- JSON pode ser carregado de API no futuro\n\n## Arquivos Afetados\n- frontend/public/data/section-templates.json (criar)\n- frontend/src/lib/section-templates.ts (criar)\n- frontend/src/types/etp.ts (remover linhas 104-358)\n- Todos os arquivos que importam SECTION_TEMPLATES\n\n## Crit√©rio de Sucesso\n- Busca por SECTION_TEMPLATES em types/etp.ts retorna 0\n- Aplica√ß√£o funciona identicamente\n- JSON v√°lido","number":33,"title":"[Frontend][Refatora√ß√£o] Mover SECTION_TEMPLATES para arquivo JSON"},{"body":"## Descri√ß√£o\nO ETPEditor.tsx (188 linhas) √© muito grande e gerencia muitas responsabilidades. Deve ser dividido em subcomponentes.\n\n## Tarefas\n- [ ] Criar components/etp/ETPEditorHeader.tsx (extrair linhas 80-91)\n- [ ] Criar components/etp/ETPEditorProgress.tsx (extrair linhas 92-100)\n- [ ] Criar components/etp/ETPEditorTabsList.tsx (extrair linhas 102-113)\n- [ ] Criar components/etp/ETPEditorContent.tsx (extrair linhas 116-150)\n- [ ] Criar components/etp/ETPEditorSidebar.tsx (extrair linhas 153-165)\n- [ ] Refatorar ETPEditor.tsx para compor esses componentes\n- [ ] Criar testes para CADA subcomponente\n- [ ] Atualizar teste do ETPEditor principal\n\n## Resultado Esperado\nETPEditor.tsx reduzido de 188 para ~60 linhas\n\n## Arquivos Afetados\n- frontend/src/components/etp/ETPEditorHeader.tsx (criar)\n- frontend/src/components/etp/ETPEditorProgress.tsx (criar)\n- frontend/src/components/etp/ETPEditorTabsList.tsx (criar)\n- frontend/src/components/etp/ETPEditorContent.tsx (criar)\n- frontend/src/components/etp/ETPEditorSidebar.tsx (criar)\n- frontend/src/pages/ETPEditor.tsx (modificar)\n\n## Crit√©rio de Sucesso\n- ETPEditor.tsx tem no m√°ximo 70 linhas\n- Cada subcomponente tem teste unit√°rio\n- Funcionalidade permanece id√™ntica","number":32,"title":"[Frontend][Refatora√ß√£o] Dividir ETPEditor.tsx em subcomponentes menores"},{"body":"## Descri√ß√£o\nO ETPs.tsx filtra ETPs em cada render sem useMemo.\n\n## Problema (linhas 24-27)\n```typescript\nconst filteredETPs = etps.filter((etp) =>\n  etp.title.toLowerCase().includes(search.toLowerCase()) ||\n  etp.description?.toLowerCase().includes(search.toLowerCase())\n);\n```\n\n## Tarefas\n- [ ] Adicionar useMemo para filteredETPs\n- [ ] Calcular search.toLowerCase() apenas uma vez\n- [ ] Depend√™ncias: [etps, search]\n- [ ] Testar que p√°gina ETPs funciona identicamente\n\n## Solu√ß√£o\n```typescript\nconst filteredETPs = useMemo(() => {\n  const lowerSearch = search.toLowerCase();\n  return etps.filter((etp) =>\n    etp.title.toLowerCase().includes(lowerSearch) ||\n    etp.description?.toLowerCase().includes(lowerSearch)\n  );\n}, [etps, search]);\n```\n\n## Arquivos Afetados\n- frontend/src/pages/ETPs.tsx\n\n## Crit√©rio de Sucesso\n- useMemo adicionado\n- Depend√™ncias corretas\n- Testes passam","number":31,"title":"[Frontend][Refatora√ß√£o] Adicionar useMemo em ETPs.tsx para filteredETPs"},{"body":"## Descri√ß√£o\nO Dashboard.tsx calcula stats filtrando array 2 vezes em cada render sem useMemo.\n\n## Problema (linhas 21-25)\n```typescript\nconst stats = {\n  total: etps.length,\n  inProgress: etps.filter((e) => e.status === 'in_progress').length,\n  completed: etps.filter((e) => e.status === 'completed').length,\n};\n```\n\n## Tarefas\n- [ ] Adicionar useMemo para stats\n- [ ] Usar reduce() para uma √∫nica itera√ß√£o ao inv√©s de duas\n- [ ] Depend√™ncias: [etps]\n- [ ] Testar que Dashboard renderiza identicamente\n- [ ] Verificar performance com muitos ETPs (opcional)\n\n## Solu√ß√£o\n```typescript\nconst stats = useMemo(() => {\n  return etps.reduce((acc, etp) => {\n    acc.total++;\n    if (etp.status === 'in_progress') acc.inProgress++;\n    if (etp.status === 'completed') acc.completed++;\n    return acc;\n  }, { total: 0, inProgress: 0, completed: 0 });\n}, [etps]);\n```\n\n## Arquivos Afetados\n- frontend/src/pages/Dashboard.tsx\n\n## Crit√©rio de Sucesso\n- useMemo adicionado\n- Testes passam\n- Performance melhor","number":30,"title":"[Frontend][Refatora√ß√£o] Adicionar useMemo em Dashboard.tsx para stats"},{"body":"## Descri√ß√£o\nO authStore armazena dados DUAS vezes: manualmente com localStorage.setItem() E atrav√©s do zustand persist. Isso √© redundante e pode causar bugs de sincroniza√ß√£o.\n\n## Problema\n- Linhas 34-35, 60-61: localStorage manual\n- Linhas 96-103: zustand persist\n- Risco de dessincroniza√ß√£o\n\n## Tarefas\n- [ ] Remover TODAS as chamadas manuais a localStorage.setItem/removeItem\n- [ ] Confiar APENAS no zustand persist\n- [ ] Verificar configura√ß√£o do persist() est√° correta\n- [ ] Testar: Login ‚Üí fechar aba ‚Üí reabrir ‚Üí ainda autenticado\n- [ ] Testar: Logout ‚Üí fechar aba ‚Üí reabrir ‚Üí n√£o autenticado\n- [ ] Atualizar testes do authStore (Issue #11)\n\n## Arquivos Afetados\n- frontend/src/store/authStore.ts\n\n## Crit√©rio de Sucesso\n- Busca por localStorage.setItem no authStore retorna 0\n- Testes passam\n- Fluxo funciona identicamente","number":29,"title":"[Frontend][Refatora√ß√£o] Corrigir duplica√ß√£o de localStorage em authStore"},{"body":"## Descri√ß√£o\nO m√©todo `generateSection()` possui 120 linhas e 10 etapas. Conforme Clean Code (12:49), fun√ß√µes devem ter no m√°ximo 20-30 linhas.\n\n## Tarefas\n- [ ] Extrair `buildEnrichedPrompt()` (linhas 58-83)\n- [ ] Extrair `generateWithLLM()` (linhas 86-94)\n- [ ] Extrair `postProcessContent()` (linhas 97-104)\n- [ ] Extrair `runValidations()` (linhas 107-115)\n- [ ] Refatorar `generateSection()` para orquestrar essas fun√ß√µes\n- [ ] Criar testes unit√°rios para CADA fun√ß√£o extra√≠da\n- [ ] Garantir testes de integra√ß√£o continuam passando\n\n## Arquivos Afetados\n- `backend/src/modules/orchestrator/orchestrator.service.ts` (modificar)\n- `backend/src/modules/orchestrator/orchestrator.service.spec.ts` (adicionar testes)\n\n## Crit√©rio de Sucesso\n- `generateSection()` tem no m√°ximo 30 linhas\n- Cada fun√ß√£o extra√≠da tem no m√°ximo 25 linhas\n- 5+ novos testes unit√°rios\n- Testes de integra√ß√£o passam","number":28,"title":"[Backend][Refatora√ß√£o] Quebrar OrchestratorService.generateSection() em fun√ß√µes menores"},{"body":"## Descri√ß√£o\nO projeto menciona compliance WCAG 2.1 AA, mas n√£o possui testes automatizados de acessibilidade.\n\n## Tarefas\n- [ ] Instalar: `npm install -D axe-core axe-puppeteer`\n- [ ] Criar `e2e/accessibility.spec.ts`\n- [ ] Testar p√°ginas: /login, /register, /dashboard, /etps, /etps/:id\n- [ ] Rodar axe-core em cada p√°gina\n- [ ] Verificar viola√ß√µes WCAG AA = 0\n\n## Exemplo\n```typescript\nimport { AxePuppeteer } from 'axe-puppeteer';\n\nit('Dashboard WCAG 2.1 AA', async () => {\n  await page.goto('http://localhost:5173/dashboard');\n  const results = await new AxePuppeteer(page).analyze();\n  expect(results.violations).toHaveLength(0);\n});\n```\n\n## Arquivos Afetados\n- `e2e/accessibility.spec.ts` (criar)\n\n## Crit√©rio de Sucesso\n- Teste detecta viola√ß√µes\n- P√°ginas principais passam sem viola√ß√µes\n- CI bloqueia PRs com viola√ß√µes","number":24,"title":"[E2E] Adicionar testes de acessibilidade com Axe-core"},{"body":"## Descri√ß√£o\nTeste E2E mais importante: criar ETP ‚Üí gerar se√ß√£o IA (mockada) ‚Üí salvar ‚Üí exportar PDF.\n\n## Pr√©-requisito\nIssue #22 deve estar conclu√≠da\n\n## Tarefas\n- [ ] Criar `e2e/critical-flow.spec.ts`\n- [ ] Step 1: Login\n- [ ] Step 2: Criar ETP (modal)\n- [ ] Step 3: Abrir ETP no editor\n- [ ] Step 4: Navegar para se√ß√£o I\n- [ ] Step 5: Clicar \"Gerar com IA\" (mockar API)\n- [ ] Step 6: Esperar gera√ß√£o completar\n- [ ] Step 7: Salvar se√ß√£o\n- [ ] Step 8: Repetir para se√ß√£o IV\n- [ ] Step 9: Exportar PDF\n- [ ] Step 10: Verificar download\n\n## Mock da API\n```typescript\nawait page.setRequestInterception(true);\npage.on('request', (request) => {\n  if (request.url().includes('/api/sections/')) {\n    request.respond({ status: 201, body: JSON.stringify({...}) });\n  }\n});\n```\n\n## Arquivos Afetados\n- `e2e/critical-flow.spec.ts` (criar)\n\n## Crit√©rio de Sucesso\n- Teste completo executa em <60 segundos\n- Teste passa localmente e no CI\n- PDF √© gerado","number":23,"title":"[E2E] Criar teste E2E para fluxo cr√≠tico completo"},{"body":"## Descri√ß√£o\nO v√≠deo recomenda Puppeteer (00:36, 06:07) para testar mudan√ßas de UI. O projeto j√° usa Puppeteer para PDF, mas n√£o para testes.\n\n## Tarefas\n- [ ] Instalar Puppeteer: `npm install -D puppeteer`\n- [ ] Criar pasta `e2e/` na raiz\n- [ ] Criar `e2e/puppeteer.config.js`\n- [ ] Criar `e2e/utils/setup.ts` com helpers (login, createETP)\n- [ ] Criar teste de exemplo: `e2e/login.spec.ts`\n- [ ] Teste: navegar para /login, preencher, clicar, verificar /dashboard\n- [ ] Adicionar script: `\"test:e2e\": \"cd e2e && npx tsx run-tests.ts\"`\n\n## Exemplo\n```typescript\nit('deve fazer login', async () => {\n  await page.goto('http://localhost:5173/login');\n  await page.type('#email', 'user@example.com');\n  await page.type('#password', 'password123');\n  await page.click('button[type=\"submit\"]');\n  await page.waitForNavigation();\n  expect(page.url()).toContain('/dashboard');\n});\n```\n\n## Arquivos Afetados\n- `e2e/puppeteer.config.js` (criar)\n- `e2e/utils/setup.ts` (criar)\n- `e2e/login.spec.ts` (criar)\n\n## Crit√©rio de Sucesso\n- Teste E2E executa sem erros\n- Puppeteer abre browser e interage","number":22,"title":"[E2E] Configurar Puppeteer para testes end-to-end"}]
