# Story TD-009.2: Multi-tenancy & Relations Completion

## Metadata
| Campo | Valor |
|-------|-------|
| **Parent Story** | TD-009 (Code Quality - Schema Cleanup & System Hygiene) |
| **Priority** | P3 |
| **Estimated Effort** | 6h |
| **Area** | Database / Backend |
| **Debts Addressed** | DB-NEW-07, DB-NEW-08, DB-P02 |
| **Dependencies** | TD-002 (multi-tenancy gaps) ja resolvido |
| **Blocked By** | None |

---

## Description

Como equipe de desenvolvimento, quero completar o isolamento multi-tenant com `organizationId` direto em Medicao/Ocorrencia, adicionar relacoes inversas `@OneToMany` no Contrato, e criar indexes GIN para campos JSONB — para que queries sejam eficientes, o isolamento multi-tenant seja robusto e a navegabilidade de relacoes esteja completa.

---

## Technical Debts Addressed

### DB-NEW-07: Medicao/Ocorrencia sem organizationId direto (BAIXA - 2h)

**Arquivos:**
- `backend/src/entities/medicao.entity.ts` — Nao possui `organizationId`
- `backend/src/entities/ocorrencia.entity.ts` — Nao possui `organizationId`

**Problema:** Ambas as entidades dependem de JOIN com `Contrato` para obter o `organizationId`. Isso impede queries diretas com filtro de tenant sem JOIN e complica o TenantGuard.

**Resolucao:**
1. Adicionar `@Column({ type: 'uuid', nullable: true })` para `organizationId` em ambas
2. Adicionar `@ManyToOne(() => Organization)` + `@JoinColumn({ name: 'organizationId' })`
3. Migration com backfill: `UPDATE medicoes SET "organizationId" = c."organizationId" FROM contratos c WHERE medicoes."contratoId" = c.id`
4. Mesmo para ocorrencias
5. Iniciar como `nullable: true` — futura migration pode tornar NOT NULL

### DB-NEW-08: Contrato sem relacao inversa OneToMany para Medicao/Ocorrencia (MEDIA - 2h)

**Arquivo:** `backend/src/entities/contrato.entity.ts`

**Problema:** A entidade `Contrato` nao possui `@OneToMany` para `Medicao` nem `Ocorrencia`. Isso impede:
- Navegacao `contrato.medicoes` / `contrato.ocorrencias`
- Cascade operations
- Eager/lazy loading reverso

**Resolucao:**
1. Adicionar em `Contrato`:
```typescript
@OneToMany(() => Medicao, (m) => m.contrato)
medicoes: Medicao[];

@OneToMany(() => Ocorrencia, (o) => o.contrato)
ocorrencias: Ocorrencia[];
```
2. Verificar que `Medicao.contrato` e `Ocorrencia.contrato` possuem `@ManyToOne` correspondente
3. Nao usar `eager: true` (resolvido em TD-003)

### DB-P02: Campos JSONB sem indice GIN (MEDIA - 2h)

**Arquivos:**
- `backend/src/entities/etp.entity.ts` — `metadata` (L398), `dynamicFields` (L384)
- `backend/src/entities/contract-price.entity.ts` — `metadata` (L224)

**Problema:** 3 campos JSONB sao consultados com operadores `@>` ou `?` sem index GIN, causando full table scan:
- `Etp.metadata` — usado para filtros de metadata custom
- `Etp.dynamicFields` — usado para campos dinamicos de templates
- `ContractPrice.metadata` — usado para filtros de market intelligence

**Resolucao:**
1. Criar migration com indexes GIN usando `jsonb_path_ops`:
```sql
CREATE INDEX CONCURRENTLY idx_etps_metadata_gin ON etps USING GIN (metadata jsonb_path_ops);
CREATE INDEX CONCURRENTLY idx_etps_dynamic_fields_gin ON etps USING GIN ("dynamicFields" jsonb_path_ops);
CREATE INDEX CONCURRENTLY idx_contract_prices_metadata_gin ON contract_prices USING GIN (metadata jsonb_path_ops);
```
2. Usar `CONCURRENTLY` para evitar lock (mesmo padrao de DB-IDX-01 ja implementado)
3. Nao executar dentro de transacao

---

## Acceptance Criteria

- [ ] `Medicao` possui coluna `organizationId` (uuid, nullable) com `@ManyToOne` para Organization
- [ ] `Ocorrencia` possui coluna `organizationId` (uuid, nullable) com `@ManyToOne` para Organization
- [ ] Migration de backfill popula `organizationId` em Medicao via JOIN com Contrato
- [ ] Migration de backfill popula `organizationId` em Ocorrencia via JOIN com Contrato
- [ ] `Contrato` possui `@OneToMany(() => Medicao, ...)` sem `eager: true`
- [ ] `Contrato` possui `@OneToMany(() => Ocorrencia, ...)` sem `eager: true`
- [ ] Index GIN criado em `etps.metadata` com `jsonb_path_ops`
- [ ] Index GIN criado em `etps.dynamicFields` com `jsonb_path_ops`
- [ ] Index GIN criado em `contract_prices.metadata` com `jsonb_path_ops`
- [ ] Migrations usam `CREATE INDEX CONCURRENTLY` (sem transacao)
- [ ] TenantGuard funciona para queries diretas em Medicao/Ocorrencia
- [ ] Todos os testes passam apos as alteracoes

---

## Test Plan

### Testes Unitarios
- Criar Medicao com `organizationId` valido — sucesso
- Criar Ocorrencia com `organizationId` valido — sucesso
- Acessar `contrato.medicoes` e `contrato.ocorrencias` via relacao — retorna lista correta
- Query JSONB `@>` em `Etp.metadata` — usa index GIN (verificar via EXPLAIN)

### Testes de Migration
- Backfill: 100% das Medicoes e Ocorrencias com Contrato possuem `organizationId` populado
- Orfaos: Medicoes/Ocorrencias sem Contrato mantêm `organizationId = null`
- Indexes GIN: `pg_indexes` confirma criacao dos 3 indexes

### Testes de Regressao
- Suite completa `npm test` passa
- Endpoints de Medicao, Ocorrencia, Contrato funcionam normalmente
- Queries de listagem com filtro tenant nao degradam performance

### Testes de Integracao
- TenantGuard: usuario do org A nao ve Medicoes do org B (query direta)
- `EXPLAIN ANALYZE` confirma uso de GIN indexes em queries JSONB

---

## Files Affected

| Arquivo | Mudanca |
|---------|---------|
| `backend/src/entities/medicao.entity.ts` | Adicionar `organizationId` + `@ManyToOne Organization` |
| `backend/src/entities/ocorrencia.entity.ts` | Adicionar `organizationId` + `@ManyToOne Organization` |
| `backend/src/entities/contrato.entity.ts` | Adicionar `@OneToMany Medicao` e `@OneToMany Ocorrencia` |
| `backend/src/migrations/XXXXXXXXX-AddOrgIdToMedicaoOcorrencia.ts` | Nova migration (backfill) |
| `backend/src/migrations/XXXXXXXXX-AddGinIndexesJsonb.ts` | Nova migration (GIN indexes) |
| Servicos de Medicao/Ocorrencia | Adaptar queries para usar `organizationId` direto |
| Testes unitarios | Atualizar mocks com novos campos |

---

*Story criada em 2026-02-12 por @pm (Morgan) - AIOS v3.10.0*
