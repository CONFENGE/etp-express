# Story TD-010.5: Database Partitioning Strategy

## Metadata
| Campo | Valor |
|-------|-------|
| **Parent Story** | TD-010 (Backlog - Infrastructure & Long-term Improvements) |
| **Priority** | P4 (Backlog - implementar quando volume justificar) |
| **Estimated Effort** | 24h |
| **Area** | Database / Performance / Infrastructure |
| **Debts Addressed** | DB-P03, DB-P07 |
| **Dependencies** | None |
| **Blocked By** | Volume de dados (gatilho: 5M+ registros em contract_prices) |

---

## Description

Como equipe de infraestrutura, quero uma estrategia de partitioning documentada e implementavel para `contract_prices` (por data) e `sinapi_items`/`sicro_items` (por UF), para que quando o volume de dados atingir milhoes de registros, a performance de queries seja mantida sem refatoracao emergencial.

**IMPORTANTE:** Esta story e de PLANEJAMENTO e PREPARACAO. A implementacao efetiva so deve ocorrer quando o volume de dados justificar (5M+ registros em `contract_prices`).

---

## Technical Debts Addressed

### DB-P03: contract_prices sem particao (BAIXA - 16h)

**Arquivo:** `backend/src/entities/contract-price.entity.ts` (linha 62)

**Problema:** Tabela `contract_prices` de market intelligence pode crescer para milhoes de registros conforme dados de licitacoes sao coletados. Sem partitioning, queries filtradas por data ou UF se tornam lentas.

**Status atual:** A tabela ja possui 10+ indexes (criados em TD-004). Partitioning so se justifica apos 5M+ registros quando indexes sozinhos nao sao suficientes.

**Estrategia recomendada:**
1. **Partitioning por `dataHomologacao`** (RANGE partition por mes/ano)
2. Permite partition pruning em queries filtradas por periodo
3. Facilita arquivamento de dados antigos (detach partition)

**Schema de partitioning:**
```sql
-- Criar tabela particionada
CREATE TABLE contract_prices_partitioned (
  LIKE contract_prices INCLUDING ALL
) PARTITION BY RANGE (data_homologacao);

-- Criar partitions por ano-mes
CREATE TABLE contract_prices_2025_01 PARTITION OF contract_prices_partitioned
  FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');
-- ... por periodo
```

### DB-P07: SINAPI/SICRO sem particao por UF (BAIXA - 8h)

**Contexto:** Tabelas `sinapi_items` e `sicro_items` armazenam dados de precos por estado (UF). Sem partitioning, queries filtradas por UF fazem scan em todos os registros de todos os estados.

**Estrategia recomendada:**
1. **Partitioning por `uf`** (LIST partition com 27 UFs)
2. Permite partition pruning em queries filtradas por estado
3. Permite refresh parcial por UF sem impactar outros estados

**Schema de partitioning:**
```sql
CREATE TABLE sinapi_items_partitioned (
  LIKE sinapi_items INCLUDING ALL
) PARTITION BY LIST (uf);

CREATE TABLE sinapi_items_sp PARTITION OF sinapi_items_partitioned
  FOR VALUES IN ('SP');
CREATE TABLE sinapi_items_rj PARTITION OF sinapi_items_partitioned
  FOR VALUES IN ('RJ');
-- ... 27 UFs
```

---

## Acceptance Criteria

### Fase 1: Planejamento (implementar agora)
- [ ] Documento de estrategia de partitioning criado (`docs/architecture/partitioning-strategy.md`)
- [ ] Scripts de partitioning preparados (nao executados)
- [ ] Gatilhos de ativacao definidos (volume de dados)
- [ ] Procedimento de migracao documentado (zero-downtime)
- [ ] Impacto em TypeORM entities documentado
- [ ] Monitoramento de volume configurado (alerta em 5M registros)

### Fase 2: Implementacao (quando volume justificar)
- [ ] Tabela `contract_prices` particionada por `dataHomologacao`
- [ ] Tabelas `sinapi_items`/`sicro_items` particionadas por `uf`
- [ ] Partition pruning confirmado via `EXPLAIN ANALYZE`
- [ ] TypeORM entities atualizadas para funcionar com tabelas particionadas
- [ ] Procedimento de arquivamento de partitions antigas documentado
- [ ] Performance de queries testada antes/depois

---

## Test Plan

### Fase 1 (Planejamento)
- Scripts de partitioning executam sem erro em ambiente de teste
- Schema particionado e identico ao original (exceto partitions)
- TypeORM funciona com tabelas particionadas (insert, select, update, delete)

### Fase 2 (Implementacao)
- Partition pruning: `EXPLAIN ANALYZE` mostra apenas partitions relevantes
- INSERT em tabela particionada vai para partition correta
- Queries filtradas por data/UF sao mais rapidas que antes
- Queries sem filtro nao degradam (partition scan completo)
- Detach de partition antiga funciona sem downtime

---

## Files Affected

| Arquivo | Mudanca |
|---------|---------|
| `docs/architecture/partitioning-strategy.md` | **NOVO** - Estrategia completa |
| `backend/scripts/partition-contract-prices.sql` | **NOVO** - Script preparado |
| `backend/scripts/partition-sinapi-sicro.sql` | **NOVO** - Script preparado |
| `backend/src/entities/contract-price.entity.ts` | (Fase 2) Adaptar para partitioning |
| `backend/src/migrations/XXXXXXXXX-PartitionContractPrices.ts` | (Fase 2) Migration |
| `backend/src/migrations/XXXXXXXXX-PartitionSinapiSicro.ts` | (Fase 2) Migration |

---

## Gatilhos de Ativacao

| Tabela | Volume Atual | Gatilho | Acao |
|--------|-------------|---------|------|
| `contract_prices` | < 100K registros | 5M+ registros | Implementar partitioning por data |
| `sinapi_items` | < 50K registros | 1M+ registros | Implementar partitioning por UF |
| `sicro_items` | < 50K registros | 1M+ registros | Implementar partitioning por UF |

**Como monitorar:**
```sql
SELECT relname, n_live_tup AS row_count
FROM pg_stat_user_tables
WHERE relname IN ('contract_prices', 'sinapi_items', 'sicro_items')
ORDER BY n_live_tup DESC;
```

---

*Story criada em 2026-02-12 por @pm (Morgan) - AIOS v3.10.0*
